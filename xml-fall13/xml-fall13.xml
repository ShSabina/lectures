<?xml version="1.0" encoding="UTF-8"?>
<?hotspot layout-path="hotspot/hotspot/layout" ?>
<?hotspot kilauea-path="hotspot/kilauea" ?>
<?hotspot layout="ischool" ?>
<hotspot xmlns="http://dret.net/xmlns/hotspot/1" xmlns:hotspot="http://dret.net/xmlns/hotspot/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dret.net/xmlns/hotspot/1 hotspot/hotspot/schemas/hotspot.xsd">
	<configuration>
		<link subsections="yes" bookmarks="yes" versions="xml-fall13.xml" home="./" help="quick" contents="./" glossary="http://dret.net/glossary/" author="http://dret.net/netdret/"/>
		<paths img="img" listing="src"/>
		<outline count-text=" [*]" count-depth="all"/>
		<hyperlink extra=""/>
		<extension file="html" link=""/>
		<counter separator=":&#160;"/>
		<kilauea xmlns="http://xmlns.sharpeleven.net/kilauea">
			<plugins>
				<touch/>
			</plugins>
		</kilauea>
	</configuration>
	<license uri="http://creativecommons.org/licenses/by/3.0/" short="CC 3.0">
		<div class="license">
			<p><a rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" src="hotspot/hotspot/layout/ischool/ischool/somerights20.png" border="0" height="31" width="88"/></a></p>
			<p><a class="outlink" rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/">This work is licensed under a CC<br/>Attribution 3.0 Unported License</a></p>
		</div>
	</license>
	<title short="XML Foundations"><a href="./" title="Course Homepage">XML Foundations</a><br/>Fall 2013 &#x2014; INFO 242 (CCN 41613)</title>
	<author short="E. Wilde" affiliation="UC Berkeley ISchool"><a href="http://dret.net/netdret/">Erik Wilde</a></author>
	<affiliation short="UC Berkeley ISchool"><a href="http://www.berkeley.edu/" title="University of California, Berkeley">UC Berkeley</a> <a href="http://ischool.berkeley.edu/" title="ISchool">School of Information</a></affiliation>
	<date short="Fall 2013">Fall Semester 2013</date>
	<copyright>2013 Erik Wilde</copyright>
	<categories>
		<category element="xml" class="xml" name="XML"/>
		<category element="elem" class="xml elem" name="XML Element"/>
		<category element="html" class="html" name="HTML"/>
		<category element="htmla" class="html" name="HTML Attribute"/>
		<category element="htmel" class="html elem" name="HTML Element"/>
		<category element="cssp" class="css" name="CSS Property"/>
		<category element="csss" class="css" name="CSS Selector"/>
		<category element="css" class="css" name="CSS"/>
		<category element="xlink" class="xml" name="XLink"/>
		<category element="xpathf" class="xpath" name="XPath Function"/>
		<category element="xpath" class="xpath" name="XPath"/>
		<category element="xslte" class="xslt elem" name="XSLT Element"/>
		<category element="xslta" class="xslt" name="XSLT Attribute"/>
		<category element="xslt" class="xslt" name="XSLT"/>
		<category element="xsde" class="xsd elem" name="XSD Element"/>
		<category element="xsda" class="xsd" name="XSD Attribute"/>
		<category element="xsd" class="xsd" name="XSD"/>
		<category element="xq" class="xq" name="XQuery"/>
		<category element="uri" class="uri" name="URI"/>
		<category element="http" class="http" name="HTTP"/>
		<category element="mime" class="mime" name="MIME"/>
		<category element="atom" class="atom" name="Atom"/>
	</categories>
	<toc name="toc.html">
		<table rules="all" cellspacing="0" cellpadding="5" width="100%">
			<thead>
				<tr>
					<th valign="bottom">Date</th>
					<th valign="bottom">Subject</th>
					<th valign="bottom">Slides</th>
					<th valign="bottom">Additional Resources</th>
					<!-- <th valign="bottom"><a href="a/">Assignments</a></th> -->
				</tr>
			</thead>
			<tbody>
				<hotspot:for-each-presentation>
					<tr class="vevent">
						<td align="right" valign="top"><hotspot:date/></td>
						<td valign="top">
							<hotspot:if-toc class="author">
								<span class="guest">Guest Lecture by <hotspot:toc class="author"/> : </span>
							</hotspot:if-toc>
							<b><span class="summary"><hotspot:title/></span><span class="toggle">:</span></b> <span class="toggle"><span class="description"><hotspot:toc class="abstract"/></span></span>
							<div style="display : none">
								<span class="dtstart"><hotspot:date/>T09:00</span>
								<span class="dtend"><hotspot:date/>T10:30</span>
								<span class="location">205 South Hall, UC Berkeley</span>
							</div>
						</td>
						<td align="center"><hotspot:presentation-link title="Lecture Slides"><hotspot:title form="short"/></hotspot:presentation-link> <span class="toggle"><hotspot:slides>(*&#160;Slides)</hotspot:slides></span></td>
						<td align="center"><hotspot:toc class="resources"/></td>
						<!-- <td align="center"><hotspot:toc class="assignment"/></td> -->
					</tr>
				</hotspot:for-each-presentation>
			</tbody>
		</table>
	</toc>
	<presentation id="intro">
		<title short="Introduction">Overview and Introduction</title>
		<date>2013-09-04</date>
		<toc class="resources"><a href="http://www.w3.org/Press/1998/XML10-REC">XML 1.0 Press Release</a>&#160;· <a href="http://www.tbray.org/ongoing/When/200x/2008/02/10/XML-People" title="Tim Bray: XML People">XML People</a></toc>
		<toc class="abstract">The <em>Extensible Markup Language (XML)</em> has been introduced in 1998 to enable content providers to publish their content on the Web in an application-specific format. HTML was considered as conveying not enough semantics, since its only purpose was (and is) the preparation of content for Web-based publishing. XML was the first step towards machine-readable data formats for the Web, a trend that since its invention has been taken to higher levels with the idea of the <em>Semantic Web</em>. XML appeared when the Web was in the steepest part of its success curve, and since then has taken over as the globally accepted format for the exchange of machine-readable structured data.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Varia</title>
			<slide id="dret-info">
				<title>About Me</title>
				<ul>
					<li>Erik Wilde exists on <a href="http://dret.net/netdret/">the Web</a>, <a href="https://twitter.com/dret" title="@dret">Twitter</a>, <a href="http://www.flickr.com/photos/dret/">Flickr</a>, and <a href="http://dret.typepad.com/dretblog/" title="dretblog">his blog</a></li>
					<li>Computer Science in <a href="http://www.tu-berlin.de/eng/" title="Technical University of Berlin (TUB)">Berlin</a>, Ph.D. in <a href="http://www.ethz.ch/index_EN" title="Swiss Federal Institute of Technology">Zürich</a></li>
					<li>Post-Doc at <a href="http://www.icsi.berkeley.edu/" title="International Computer Science Institute">ICSI</a>, Berkeley (1997/98)</li>
					<li>Various activities in Switzerland (1998-2006)</li>
					<ul>
						<li>teaching at <a href="http://www.ethz.ch/index_EN">ETH Zürich</a> and <a href="http://www.fhnw.ch/">FHNW</a></li>
						<li>working as independent consultant (training, courses, consulting)</li>
						<li>research in <a href="http://dret.net/projects/">various XML-related areas</a></li>
					</ul>
					<li>Professor at the <a href="http://ischool.berkeley.edu/">School of Information</a> (2006-11)</li>
					<ul>
						<li>Technical Director of the <a href="http://isd.ischool.berkeley.edu/">Information and Service Design (ISD) program</a></li>
					</ul>
					<li>Architect at <a href="http://www.emc.com/">EMC</a>'s <a href="http://web.emc.com/informationintelligence">Information Intelligence Group (IIG)</a> (since 2011)</li>
					<ul>
						<li>providing guidance and guidelines for IIG's RESTful SOA</li>
					</ul>
				</ul>
			</slide>
			<slide id="course-info">
				<title>About this Course</title>
				<ul>
					<li>Course Web page: <code><a href="./">http://dret.net/lectures/xml-fall13/</a></code></li>
					<li>All sources (XML/examples/images) <a href="https://github.com/dret/lectures/tree/master/xml-fall13">available at GitHub</a></li>
					<li>Course mailing list: <code><a href="mailto:xml-fall13@bspace.berkeley.edu">xml-fall13@bspace.berkeley.edu</a></code></li>
					<ul>
						<li>archived in the <a href="https://bspace.berkeley.edu/portal/site/9a83055f-77a0-4627-a276-ece16c98f8e2">bSpace</a> <a href="https://bspace.berkeley.edu/portal/site/9a83055f-77a0-4627-a276-ece16c98f8e2/page/a1285cb7-16ec-441b-8b81-efa4bbc03831">email archive</a></li>
					</ul>
					<li>Grading is based on assignments and final exam</li>
					<ul>
						<li>25% split evenly across all assignments (grading per team)</li>
						<li>25% final <q>project report</q> (graded individually)</li>
						<li>50% final exam (30min oral, taken/graded individually)</li>
					</ul>
				</ul>
			</slide>
			<slide id="slide-info">
				<title>About these Slides</title>
				<ul>
					<li>Generated from <a href="http://dret.net/projects/xslidy/">Hotspot</a> <a href="xml-fall13.xml">XML</a></li>
					<li>Designed for online presentation and use (lots of links!)</li>
					<ul>
						<li>for printing, use <q>a</q> (all slides), and then <q>s</q> (smaller font) a couple of times</li>
					</ul>
					<li>A good real-world example for XML applications</li>
					<ul>
						<li>Slidy/Kilauea is useful, but there is no support for structures and hyperlinking</li>
						<li>Hotspot adds these features by adding an XSLT transformation</li>
						<li>Hotspot is useful, but there is no interface (XML editing only)</li>
					</ul>
				</ul>
			</slide>
			<slide id="resource-info">
				<title>Additional Resources</title>
				<ul>
					<li><a href="http://dret.net/biblio/">Bibliography at <code>http://dret.net/biblio/</code></a></li>
					<ul>
						<li>suggestions, updates, corrections are very welcome (really!)</li>
					</ul>
					<li>The <a href="http://www.w3.org/"><em>World Wide Web Consortium (W3C)</em></a></li>
					<ul>
						<li>the organization which invented XML</li>
						<li>as well as (almost) all other technologies covered in this course</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="why-xml">
			<title>Why/How/Where XML is Useful</title>
			<slide>
				<title>XML is a Metalanguage</title>
				<ul>
					<li>XML can be used to represent any kind of structured data</li>
					<ul>
						<li>(as long as the data is modeled in a way that fits XML's metamodel)</li>
					</ul>
					<li>XQuery and XSLT can be used to process XML documents</li>
					<ul>
						<li>(or use the language of your choice and XML libraries)</li>
					</ul>
					<li>XML formats can be designed to be flexible and extensible</li>
					<ul>
						<li>(this requires good modeling skills <em>and</em> good XML skills)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>GPS Track Visualization</title>
				<img src="marin-run-map.png" style="height : 70% ; margin : 2% ; " href="http://app.strava.com/activities/18200957"/>
			</slide>
			<slide>
				<title>GPS Track in XML</title>
				<ul>
					<li><a href="http://app.strava.com/activities/39586316">GPS data</a> exported to <a href="http://www.topografix.com/gpx/1/1/">GPX format</a></li>
				</ul>
				<listing src="2010-01-15-1.gpx" line="1-21"/>
			</slide>
			<slide>
				<title>GPS Track Combination</title>
				<img src="heatmap-golden-gate.png" style="height : 70% ; margin : 2% ; " href="http://x.raceshape.com/heatmap/view.html?id=r1ycR0%2Fhp88VjX%2FAVO4B3gHo%2B9gyzOuMQA1uDqCn"/>
			</slide>
			<slide>
				<title>Finding Activities (Oxygen)</title>
				<listing src="find-by-location-oxygen.xq"/>
			</slide>
		</part>
		<part>
			<title>Data Formats? Databases?</title>
			<part>
				<title>Alternatives to XML</title>
				<slide id="xml-and-csv">
					<title>XML and CSV</title>
					<ul>
						<li>CSV is easier to understand and use</li>
						<li>CSV tools (such as <em>Excel</em>) are widely used and understood</li>
						<li>Structures beyond tables are hard to represent</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
				<slide id="xml-and-json">
					<title>XML and JSON</title>
					<ul>
						<li>JSON maps better into most programming languages</li>
						<li>JSON objects can be readily used as language objects</li>
						<li>Structures beyond nested objects/arrays are hard to represent</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
				<slide id="xml-and-rdf">
					<title>XML and RDF</title>
					<ul>
						<li>RDF does not have the built-in <q>tree bias</q> of XML</li>
						<li>RDF can be combined more easily across <q>documents</q></li>
						<li>Data that has some <q>natural coherence</q> is hard to manage</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
			</part>
			<part>
				<title>XML Big Data</title>
				<slide>
					<title>XML and Databases</title>
					<ul>
						<li>A data format defines a framework for certain kinds of data</li>
						<ul>
							<li>some formats are <em>metalanguages</em> such as XML, but most are not</li>
						</ul>
						<li>A database is based on a <em>data model</em> and manages data as well as access</li>
						<li>XML does not talk about databases at all</li>
						<li>It is possible to build databases that support XML's model</li>
						<ul>
							<li>data storage can be scaled beyond what filesystems can manage</li>
							<li>access to XML can be much better optimized in XML databases</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XQuery using Files</title>
					<img style="width : 86% ; margin : 4% ; " src="xquery-overview-filesystem.png" title="File-based XQuery Processing"/>
				</slide>
				<slide>
					<title>XQuery using an XML Database</title>
					<img style="width : 86% ; margin : 4% ; " src="xquery-overview-dbms.png" title="DB-based XQuery Processing"/>
				</slide>
				<slide>
					<title>Moving Data into a Database</title>
					<img src="xDB-import.png" style="height : 70% ; margin : 2% ; " href="http://developer.emc.com/docs/documentum/xdb/manual/index.html#doc:task/adminclient_importing_data.html"/>
				</slide>
				<slide>
					<title>Finding Activities (xDB)</title>
					<listing src="find-by-location-xdb.xq"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XML is a Hammer</title>
				<ul>
					<li>XML is just one way to represent structured data</li>
					<li>Like all models/metamodels, XML has limitations and side-effects</li>
					<li>XML's tool chain allow to adapt to a variety of scenarios</li>
					<li>XML databases support scalable access to <q>XML Big Data</q></li>
					<li>As with all tools: know the tool, know the alternatives</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="basics">
		<title short="Basics">XML Basics</title>
		<date>2013-09-09</date>
		<toc class="resources"><a href="http://www.w3.org/TR/REC-xml/" title="W3C XML 1.0 Specification">XML&#160;1.0&#160;Spec</a>&#160;· <a href="http://dret.net/netdret/docs/wilde-cacm2008-xml-fever.html" title='Erik Wilde and Robert J. Glushko, "XML Fever", Communications of the ACM, 51(7):40-46, July 2008'>XML&#160;Fever</a></toc>
		<toc class="abstract">The <em>Extensible Markup Language (XML)</em> defines a simple way for structuring data. The power and popularity of XML can be explained by its versatility, the platform-independence, the standards and technologies leveraging it, and the number of tools and products supporting it. Understanding XML itself is rather simple, as it only depends on a very small set of other technologies. Unicode is the most important foundation of XML. XML itself specifies two different things: on the one hand the format for structured data, which are called <em>XML documents</em>, and on the other hand a constraint language for XML documents, which is called <em>Document Type Definition (DTD)</em>.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Foundations for XML</title>
			<slide>
				<title>Identifications</title>
				<ul>
					<li>Identification of Character Encodings</li>
					<ul>
						<li>text can be encoded using different character sets and encodings</li>
						<li>IANA maintains the <a href="http://www.iana.org/assignments/character-sets">official list of character encodings</a></li>
						<li>character encoding is about <em>characters</em>, not about <em>text</em></li>
					</ul>
					<li>Identification of Languages</li>
					<ul>
						<li>textual content should be tagged with language information</li>
						<li>specification based on <a href="http://www.loc.gov/standards/iso639-2/langhome.html">ISO 639 language tags</a></li>
						<li>language identification is about <em>text</em>, not about <em>characters</em></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XML's Idea of Content and Names</title>
				<p>XML documents can use a wide array of characters. They are defined by <a href="http://www.unicode.org/">Unicode</a>, which currently (Version 5.0) defines more than 100'000 characters (#100'000 added in 2005).</p>
				<listing src="japanese1.xml"/>
				<listing src="japanese2.xml"/>
			</slide>
			<slide>
				<title>XML and Unicode</title>
				<ul>
					<li>XML is based on Unicode</li>
					<ul>
						<li>XML is defined in terms of <a href="http://www.w3.org/TR/xml/#sec-starttags">character structures</a></li>
						<li>how these characters are encoded is not part of XML</li>
					</ul>
					<li>How are XML documents encoded?</li>
					<ul>
						<li>applications can use any character encoding they like</li>
						<li>XML processors <em>must</em> support UTF-8 and UTF-16</li>
						<li>XML processors <em>may</em> support any number of additional encodings</li>
					</ul>
					<li>How is the encoding <q>encoded</q>?</li>
					<ul>
						<li>part of the XML document: <code>&lt;?xml version="1.0" encoding="UTF-8"?></code></li>
						<li>bootstrap problem solved heuristically or by out-of-band information</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>XML</title>
			<slide>
				<title>XML Use Cases</title>
				<ul>
					<li>XML is a metalanguage supporting application-specific vocabularies</li>
					<li><em>RSS</em> (and <em>Atom</em>) are XML vocabularies for newsfeeds</li>
					<ul>
						<li><a href="http://docordie.blogspot.com/">Doc or Die</a>: <a href="http://docordie.blogspot.com/rss.xml">RSS feed</a> vs. <a href="http://docordie.blogspot.com/atom.xml">Atom feed</a></li>
						<li>browsers now incorporate and/or integrate newsfeed readers</li>
					</ul>
					<li><em>OpenDocument (ODF)</em> is a language for office application documents</li>
					<ul>
						<li>designed for open and interoperable exchange</li>
						<li>standardized by ISO (which now also standardizes Microsoft's <em>Open XML</em>)</li>
					</ul>
					<li><em>Scalable Vector Graphics (SVG)</em> for portable vector graphics</li>
					<ul>
						<li>designed for embedding in Web pages</li>
						<li>good example for compound documents: <a href="http://www.carto.net/papers/svg/animated_weather_symbols/">HTML containing SVG</a></li>
					</ul>
				</ul>
			</slide>
			<part>
				<title>XML Documents</title>
				<slide>
					<title>Markup?</title>
					<ul>
						<li>Structures are encoded using special characters</li>
						<ul>
							<li>a fundamental difference when comparing to binary formats</li>
							<li>markup languages can be read and modified using text-based tools</li>
							<li>programs must treat markup characters in a special way</li>
						</ul>
						<li>Documents are content interspersed with markup (i.e., structures)</li>
						<ul>
							<li>XML-aware software interprets the markup</li>
							<li>XML-unaware software just sees a text file</li>
							<li>modifications must be made XML-aware (e.g., inserting <q>AT&amp;T</q> as <q>AT&amp;amp;T</q>)</li>
						</ul>
						<li>You have to pay the <link href="markup-price"/></li>
					</ul>
				</slide>
				<slide>
					<title>Basic Concepts</title>
					<ul>
						<li>XML Documents have an <em>XML declaration</em> (optional)</li>
						<li>There is exactly one <em>document element</em> (a.k.a. <em>root element</em>)</li>
						<li>Elements may be nested (there is no conceptual limit)</li>
						<ul>
							<li>elements may be repeated (they can be identified by position)</li>
						</ul>
						<li>Elements are marked up using <em>tags</em></li>
						<ul>
							<li>most elements have content, surrounded by <em>start</em> and <em>end tags</em></li>
							<li>empty elements are allowed and may use a special notation</li>
						</ul>
						<li>Elements may have attributes (zero to any number)</li>
						<ul>
							<li>attributes can only occur once on an element (i.e., they cannot be repeated)</li>
						</ul>
					</ul>
					<listing src="my-first.xml"/>
				</slide>
				<slide id="xmltree">
					<title>Tree Syntax</title>
					<ul>
						<li>Markup is important, but only a notation</li>
						<li>XML documents are trees with different node types</li>
						<ul>
							<li>nodes so far: document, element, attribute, text</li>
						</ul>
						<img style="width : 90% ; margin : 4% ;" src="document-tree.png" title="XML document tree"/>
					</ul>
				</slide>
				<slide id="xmlelements">
					<title>Elements</title>
					<ul>
						<li>Elements can use a <a href="http://www.w3.org/TR/xml/#NT-Name">wide variety of names</a></li>
						<ul>
							<li>Allowed: <elem>html</elem>, <elem>id9832798472</elem>, <elem>_</elem>, <elem>:</elem>, <elem>こんにちは</elem></li>
							<li>Disallowed: leading numbers, spaces, control characters</li>
						</ul>
						<li>Element names usually convey some information about the content</li>
						<ul>
							<li>this is not reliable and highly language-dependent</li>
							<li>it is <em>very useful</em> when working with a known vocabulary</li>
							<li>it is <em>potentially harmful</em> when working with an unknown vocabulary</li>
						</ul>
						<li>Elements are the foundation for XML's versatility</li>
						<ul>
							<li>they can be nested (<code>&lt;address>&lt;city>Berkeley&lt;/city>&lt;zip>94709&lt;/zip>…</code>)</li>
							<li>they can be repeated (<code>&lt;givenname>Erik&lt;/givenname>&lt;givenname>Thomas&lt;/givenname></code>)</li>
							<li>their sequence can convey additional information (given names have a sequence)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Attributes</title>
					<ul>
						<li>Additional information pertaining to elements</li>
						<li>Traditionally, anything that is not considered <q>content</q></li>
						<ul>
							<li>SGML is a document markup language</li>
							<li>XML uses SGML's concepts</li>
							<li>XML has its roots in the document world</li>
						</ul>
						<li>Elements: Content (i.e., Data); Attributes: Metadata</li>
						<li>Documents often distinguish by what is textual content</li>
					</ul>
					<listing src="section.xml" line="12-20"/>
				</slide>
				<slide>
					<title>Attribute Syntax</title>
					<ul>
						<li>Naming rules are the same as for <link href="xmlelements"/></li>
						<li>Attributes always appear within an element's <em>start tag</em></li>
						<li>Attributes are <a href="http://www.w3.org/TR/xml/#NT-Attribute">name/value-pairs</a></li>
						<ul>
							<li>the value is enclosed in single or double quotes</li>
						</ul>
						<li>Attribute with a single-quote value: <elem>elem attr="Single: '"/</elem></li>
						<li>Attribute with a double-quote value: <elem>elem attr='Double :"'/</elem></li>
						<li>How can attribute values contain both?</li>
					</ul>
				</slide>
				<slide id="markup-price">
					<title>The Price for Markup</title>
					<ul>
						<li>Markup characters have a special meaning</li>
						<ul>
							<li><q>&lt;</q> opens a tag</li>
							<li>for attribute values, quotes delimit the value</li>
						</ul>
						<li>The literal use of a markup character requires escaping</li>
						<ul>
							<li>XML's <em>entities</em> can refer to pieces of content</li>
							<li>entity syntax is <code>&amp;name;</code> for referring to the entity <q><code>name</code></q></li>
							<li>XML has 5 <a href="http://www.w3.org/TR/xml/#sec-predefined-ent">predefined entities</a>: <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, <code>&amp;apos;</code>, <code>&amp;quot;</code></li>
						</ul>
						<li>Attribute using both kinds of quotes: <code>&lt;elem attr="Single ' and Double &amp;quot;"/></code></li>
					</ul>
					<pre><![CDATA[<li>Attribute using both kinds of quotes: <code>&lt;elem attr="Single ' and Double &amp;quot;"/></code></li>]]></pre>
				</slide>
				<slide id="mixed-content">
					<title>Mixed Content</title>
					<p>The term <em>Mixed content</em> in XML refers to elements <a href="http://www.w3.org/TR/xml/#sec-mixed-content">which have text content mixed with elements</a>. What these elements do depends on the elements <img style="height : 1em" src="smiley.gif"/>, but the important point is that they are on the same level as the text nodes of the mixed content.</p>
					<pre><![CDATA[<p>The term <em>Mixed content</em> in XML refers to elements <a href="http://www.w3.org/TR/xml/#sec-mixed-content">which have text content mixed with elements</a>. What these elements do depends on the elements <img style="height : 1em" src="smiley.gif"/>, but the important point is that they are on the same level as the text nodes of the mixed content.</p>]]></pre>
					<img style="width : 90% ; margin : 4% ;" src="mixed-content.png" title="XML tree for mixed content"/>
				</slide>
				<slide>
					<title>Mixed Content Usage</title>
					<ul>
						<li>Database people find mixed content irritating</li>
						<ul>
							<li>cannot be easily mapped to relational structures</li>
							<li>is more <em>document-like</em> than <em>data-like</em></li>
							<li>much harder to optimize for query analysis and query processing</li>
						</ul>
						<li>Document people find mixed content very intriguing</li>
						<ul>
							<li>textual content can still be used as simple text</li>
							<li>markup provides additional information for rich text</li>
							<li>start with a text-only document and use markup to add structure to it</li>
						</ul>
					</ul>
				</slide>
				<slide id="whitespace">
					<title>Whitespace</title>
					<ul>
						<li>XML documents often are pretty-printed</li>
						<li><em>Whitespace text nodes</em> often are <q>not really content</q></li>
						<ul>
							<li>XML whitespace characters are <em>space</em>, <em>tab</em>, <em>newline</em>, and <em>carriage return</em></li>
							<li>whitespace text nodes are text nodes containing <em>only</em> whitespace characters</li>
						</ul>
						<img style="width : 90% ; margin : 4% ;" src="document-tree-whitespace.png" title="XML tree with whitespace text nodes"/>
					</ul>
				</slide>
				<slide>
					<title>Significant Whitespace</title>
					<ul>
						<li>Some whitespace text nodes are relevant</li>
						<li>Usually text nodes in <em>mixed content</em> elements</li>
					</ul>
					<p>Whitespace <i>can be</i> <u>very</u> <b>important</b>!</p>
					<pre><![CDATA[<p>Whitespace <i>can be</i> <u>very</u> <b>important</b>!</p>]]></pre>
					<img style="height : 40% ; margin : 2% ;" src="significant-whitespace.png" title="XML tree containing significant whitespace"/>
				</slide>
			</part>
			<part id="wellformed">
				<title>Processing XML</title>
				<slide>
					<title>Observing XML Syntax</title>
					<ul>
						<li>XML's syntax requires you to use the right characters</li>
						<ul>
							<li><a href="http://www.w3.org/TR/xml/#NT-element">the grammar alone</a> allows many XML errors</li>
							<li><a href="http://www.w3.org/TR/xml/#GIMatch">additional constraints</a> ensure that everything is used correctly</li>
						</ul>
						<li><em>XML processors</em> (a.k.a. <em>XML parsers)</em> check for these rules</li>
						<ul>
							<li>if there are problems, the document cannot be interpreted as XML</li>
							<li>otherwise, the document is said to be <em>well-formed</em></li>
						</ul>
						<li>Only well-formed documents can be regarded as a tree</li>
						<ul>
							<li>other documents are not XML at all, even though they may be close</li>
							<li>XML processors must report problems to the application (no guessing allowed)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Validity</title>
					<ul>
						<li><em>Well-formed documents</em> observe XML rules</li>
						<ul>
							<li>they observe the XML syntax</li>
							<li>they observe all well-formedness constraints</li>
						</ul>
						<li>Applications require the right elements and attributes</li>
						<li><em>Validity</em> is a more comprehensive concept</li>
						<li><em>Valid documents</em> observe additional rules</li>
						<ul>
							<li>they must be well-formed documents</li>
							<li>they must adhere to the constraints defined in a schema (DTD, XSD, RNG, ...)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Semantics</title>
					<ul>
						<li>XML is a language for encoding trees</li>
						<ul>
							<li>Elements and attributes are labeled node in this tree</li>
							<li>the labels can be chosen freely by document authors</li>
						</ul>
						<li>The tree's meaning is nothing XML is concerned with</li>
						<ul>
							<li>peers must have a mutual understanding of the semantics</li>
							<li>XML without mutual understanding is almost useless</li>
							<li>reverse engineering often is possible, but it is risky and brittle</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XML Documents</title>
				<ul>
					<li>XML documents are structured data using markup</li>
					<li>Elements and Attributes are the main structuring mechanisms</li>
					<li>Elements and Attributes have names, but have no inherent semantics</li>
					<li>For using XML successfully, <em>shared semantics</em> are essential</li>
					<li>Always think about semantics</li>
				</ul>
			</slide>
		</part>		
	</presentation>
	<presentation id="dtd">
		<title short="DTD">Document Type Definition (DTD)</title>
		<date>2013-09-11</date>
		<toc class="abstract">The XML specification defines a format for structured data (XML documents) and a grammar-based constraint language for these (DTD). In SGML-based systems, DTDs were often very complex and feature-rich constructs, which controlled a lot of the processing of SGML documents. XML greatly simplified DTDs, and de-facto usage of DTDs today simplified them even more. In many systems today, DTDs are not used at all or generated from sample documents. In this lecture, it is argued that DTDs (or schemas, to be more general) should be taken seriously in any non-trivial XML application, because they are a representation of the underlying (and often underspecified) data model of the application.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Schema Languages</title>
			<slide>
				<title>XML Validation</title>
				<ul>
					<li>XML knows two <q>types</q> of documents, <em>well-formed</em> and <em>valid</em></li>
					<li><em>well-formed</em> documents satisfy all basic constraints of the XML specification</li>
					<ul>
						<li>they can be parsed according to the XML grammar</li>
						<li>they satisfy the additional constraints (e.g., start and end tags match)</li>
						<li>together, this means they can be translated into a <link href="xmltree">tree</link></li>
						<li>this tree then can be processed with XML tools (<link href="sax">SAX</link>, <link href="dom">DOM</link>, <link href="xslt-1">XSLT</link>, …)</li>
					</ul>
					<li><em>valid</em> documents must satisfy the constraints of a DTD</li>
					<ul>
						<li>a document must be well-formed before it can be validated</li>
						<li>all elements and attributes have been defined</li>
						<li>elements and attributes are used according to their definition</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Validation and Applications</title>
				<img src="valid-documents.png" style="width : 90% ; margin : 4% ; "/>
			</slide>
			<slide>
				<title>Non-XML, Well-Formed, and Valid</title>
				<listing src="non.xml" line="3-9"/>
				<listing src="address-invalid.xml" line="3-9"/>
				<listing src="address-valid.xml" line="3-9"/>
			</slide>
			<slide>
				<title>DTD Example</title>
				<listing src="address-valid.xml" line="1-2"/>
				<listing src="address.dtd"/>
				<ul>
					<li>The DTD defines constraints on element and attribute usage</li>
					<li>The DTD does only in part constrain textual contents</li>
				</ul>
			</slide>
			<slide>
				<title>XML Schema Languages</title>
				<ul>
					<li>DTDs are part of XML itself</li>
					<ul>
						<li>XML specifies the document format <u>and</u> one schema language</li>
						<li>DTD support is provided by most XML processors (<a href="http://www.w3.org/TR/REC-xml/#proc-types" title="XML specification">validating processors</a>)</li>
					</ul>
					<li>Other schema languages are available</li>
					<ul>
						<li><link href="xsd-1">XSD</link> as the W3C's recommendation</li>
						<li><a href="http://www.schematron.com/">Schematron</a> as a rule-based alternative</li>
						<li>various <a href="http://dret.net/glossary/xmlschemalanguage" title="XML glossary">other research projects and products</a></li>
					</ul>
					<li>Choosing appropriate schema language(s) is important</li>
					<ul>
						<li>we look at DTDs because they are part of XML itself</li>
						<li>we look at XSD because it is widely used</li>
						<li>Schematron is interesting because it is simple and powerful</li>
						<li>you may even invent your own schema language (a.k.a. <em>meta-programming</em>)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>DTD Basics</title>
			<slide>
				<title>XML is <q>SGML light</q></title>
				<ul>
					<li>XML is a subset of SGML</li>
					<ul>
						<li>XML documents have been greatly simplified</li>
						<li>XML DTDs have retained some of SGML's peculiarities</li>
					</ul>
					<li>DTD design should be left to XML experts</li>
					<ul>
						<li>simple DTDs (for prototypes) are easy to define (or generate)</li>
						<li>serious DTDs for complex data models are hard to define</li>
					</ul>
					<li>XML is a useful tool for experiments and prototypes</li>
					<ul>
						<li>basic knowledge of DTDs is required</li>
						<li>serious XML schemas often use <link href="xsd-1">XSD</link> anyway</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Associating Documents and DTDs</title>
				<ul>
					<li>A DTD is a schema for a set of documents</li>
					<ul>
						<li>there may be just one document for a DTD, there may be billions (HTML)</li>
						<li>in most cases, DTDs are managed as a separate resource</li>
					</ul>
					<li>The <a href="http://www.w3.org/TR/xml#sec-prolog-dtd"><em>Document Type Declaration</em></a> <q>contains or points to markup declarations that provide a grammar for a class of documents</q></li>
					<ul>
						<li>the part which is contained is called <em>Internal Subset</em></li>
						<li>the part which is pointed to is called <em>External Subset</em></li>
						<li>internal and external subset together are the <em>Document Type Definition (DTD)</em></li>
					</ul>
					<li>External subsets are identified by <em>Public</em> and <em>System Identifiers</em></li>
					<ul>
						<li><em>public identifiers</em> use a special notation</li>
						<li><em>system identifiers</em> are URIs (relative or absolute)</li>
						<li>applications use (i.e., know or retrieve) the DTD for validation</li>
					</ul>
				</ul>
				<listing src="address-valid.xml" line="1-2"/>
			</slide>
			<part>
				<title>DTD Syntax</title>
				<slide>
					<title>DTDs are not XML Documents</title>
					<ul>
						<li>DTDs use a special syntax</li>
						<ul>
							<li>somewhat ironic when everything else is XMLized</li>
							<li>DTDs cannot be processed with standard XML tools</li>
							<li>more compact than XML syntax</li>
						</ul>
						<li>Definition of elements and attribute lists</li>
						<ul>
							<li>elements are defined by the content they allow</li>
							<li>attribute lists are sets of allowed attributes on elements</li>
						</ul>
					</ul>
					<listing src="address.dtd"/>
				</slide>
				<slide>
					<title>Syntax Rules</title>
					<ul>
						<li>There is no container containing the whole DTD</li>
						<ul>
							<li><code>&lt;!ELEMENT example EMPTY></code> thus is a complete DTD</li>
						</ul>
						<li>Definitions (officially called <em>declarations</em>) use <code>&lt;!… ></code> syntax</li>
						<ul>
							<li><code>ELEMENT</code> is used to <link href="dtd-element">define an element</link></li>
							<li><code>ATTLIST</code> is used to <link href="dtd-attlist">define an attribute list</link></li>
							<li><code>ENTITY</code> is used to <link href="dtd-entity">define an entity</link></li>
						</ul>
						<li>The document element is not marked explicitly</li>
						<ul>
							<li>but it must be declared in the document type declaration</li>
							<li>this means the document element is established by the document, not by the DTD</li>
						</ul>
					</ul>
				<listing src="address-valid.xml" line="1-3"/>
				</slide>
			</part>
			<part id="dtd-element">
				<title>Defining Elements</title>
				<slide id="element-only-declaration">
					<title>Element Only Content</title>
					<ul>
						<li>Element content is defined by a grammar for the children</li>
						<ul>
							<li>sequences are indicated with a comma: <q><code>,</code></q></li>
							<li>choices are indicated with a vertical bar: <q><code>|</code></q></li>
							<li>optional parts are indicated with a question mark: <q><code>?</code></q></li>
							<li>repeatable parts are indicated with a plus: <q><code>+</code></q></li>
							<li>optional and repeatable parts are indicated with a asterisk: <q><code>*</code></q></li>
							<li>parentheses can be used for grouping and nesting</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="1064-1074"/>
				</slide>
				<slide id="mixed-content-declaration">
					<title>Mixed Content</title>
					<ul>
						<li><link href="mixed-content"/> allows text content and elements to be mixed</li>
						<ul>
							<li><link href="whitespace"/> characters are allowed in <link href="element-only-declaration"/> (this must not be declared)</li>
							<li>for non-whitespace characters, character data must be allowed explicitly</li>
						</ul>
						<li>The allowed child elements may be constrained, but not their order or their number of occurrences</li>
						<li>Mixed Content always is defined as <code>&lt;!ELEMENT x (#PCDATA | a | b | …)* ></code></li>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="568-568"/>
					<ul>
						<li><em>Character only</em> content is a special case of mixed content</li>
						<ul>
							<li>the element may only contain characters (no other elements)</li>
							<li>the repetition is not necessary because there is no choice</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="355-355"/>
				</slide>
				<slide>
					<title>Empty Content</title>
					<ul>
						<li>Empty elements can be useful</li>
						<ul>
							<li>they may contain all information in attributes</li>
							<li>their presence may carry semantics without the need for additional information</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="833-848"/>
				</slide>
			</part>
			<part id="dtd-attlist">
				<title>Defining Attribute Lists</title>
				<slide>
					<title>Attributes belong to Elements</title>
					<ul>
						<li>Attributes are specified in an element's <em>Attribute List</em></li>
						<ul>
							<li>an element definition may have any number of attributes associated with it</li>
							<li>attributes may occur at most once on an element</li>
						</ul>
						<li>Attributes definitions have a <em>name</em>, a <em>type</em>, and a <em>default declaration</em></li>
						<ul>
							<li>the attribute appears according to the default declaration</li>
							<li>if the attribute is present, its value must conform to the type</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="794-801"/>
				</slide>
				<slide id="dtd-attr-type">
					<title>Attribute Types</title>
					<ul>
						<li>Attribute values can be constrained (which is not possible for element content)</li>
						<ul>
							<li><code>CDATA</code> means any character string (but no markup)</li>
							<li>enumerated types list allowed values: <code>(data|ref|object)</code> (list of XML names)</li>
							<li><code>ID</code> for identifying elements (part of <code><link href="ididref"/></code>)</li>
							<li><code>IDREF</code> for referencing identified elements (part of <code><link href="ididref"/></code>)</li>
						</ul>
						<li>Application-oriented attribute types are often <q>simulated</q></li>
						<ul>
							<li>using <link href="param-entity"/>, modeling information can be preserved</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="894-894"/>
					<listing src="xhtml1-transitional.dtd" line="52-53"/>
					<ul>
						<li>The default declaration specifies the attribute's presence</li>
						<ul>
							<li><code>#REQUIRED</code> means the attribute has to be specified (on every element)</li>
							<li><code>#IMPLIED</code> marks an optional attribute (the parser may imply a value)</li>
							<li><code>"…"</code> specifies a default value (and the attribute is optional)</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Advanced DTDs</title>
			<part id="ididref">
				<title>ID/IDREF</title>
				<slide>
					<title>References in Documents</title>
					<ul>
						<li>Without Validation, there are no IDs</li>
						<ul>
							<li><code>ID</code> is an <link href="dtd-attr-type">attribute type</link> declared in the DTD</li>
							<li><link href="xml:id"><code>xml:id</code></link> is an attempt to support schema-independent IDs</li>
						</ul>
						<li>IDs are used to assign identities to elements</li>
						<ul>
							<li>the XML processor reports duplicate IDs as errors (<a href="http://www.w3.org/TR/xml/#id">part of validation</a>)</li>
						</ul>
						<li>IDREFs are used to reference existing IDs</li>
						<ul>
							<li>the XML processor reports references to non-existing IDs as errors (<a href="http://www.w3.org/TR/xml/#idref">part of validation</a>)</li>
						</ul>
						<li>IDs must be XML Names (in particular, they may not start with a number)</li>
					</ul>
				</slide>
				<slide>
					<title>ID/IDREF in a Document</title>
					<listing src="section.xml" line="3-18"/>
					<listing src="section.dtd" line="2-12"/>
				</slide>
				<slide>
					<title>References within the Tree</title>
					<img src="section.png" style="width : 90% ; margin : 4% ; "/>
				</slide>
				<slide>
					<title>Formatting Example</title>
					<p>Hotspot can generate links to sections such as the section about <link href="ididref"/>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>
					<pre><![CDATA[<p>Hotspot can generate links to sections such as the section about <link href="ididref"/>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>]]></pre>
					<p>After running Hotspot, the following HTML is generated:</p>
					<pre><![CDATA[<p>Hotspot can generate links to sections such as the section about <a href="#ididref">ID/IDREF</a>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>]]></pre>
				</slide>
				<slide>
					<title>ID/IDREF Semantics</title>
					<ul>
						<li>Rooted in the document world</li>
						<ul>
							<li>all parts are assembled before processing</li>
							<li>names are symbolic and assigned as required</li>
							<li>mixed syntax and semantics</li>
						</ul>
						<li>Good idea, but many shortcomings</li>
						<ul>
							<li>constraints apply to one document only</li>
							<li>IDs and IDREFs are global instead of scoped</li>
							<li>identifiers should be allowed to use any type</li>
							<li>identifier processing should be type-specific (2 &#x225F; 02)</li>
						</ul>
						<li>Applications must know how to process ID/IDREF</li>
						<ul>
							<li>for HTML export, links can be generated</li>
							<li>for databases, keys should be used</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="dtd-entity">
				<title>Entities</title>
				<slide>
					<title>General Entities</title>
					<ul>
						<li>XML's core concept of physical data structures</li>
						<ul>
							<li>an entity is a named unit of data which can be referenced</li>
							<li>within documents, it is referenced by the markup <code>&amp;entity-name;</code></li>
						</ul>
						<li>Entities can be used to name and reuse document content</li>
					</ul>
					<listing src="xhtml-lat1.ent" line="135-142"/>
					<ul>
						<li><em>Character References</em> look like entities: <code>&amp;#9786;</code> or <code>&amp;#x263A;</code> = &#x263A;</li>
						<ul>
							<li>they can be used to represent any Unicode character, they are processed as single characters</li>
						</ul>
					</ul>
				</slide>
				<slide id="param-entity">
					<title>Parameter Entities</title>
					<ul>
						<li>Parameter entities are parsed entities for use within the DTD</li>
						<ul>
							<li>a parameter entity must be specifically declared as such</li>
							<li>within DTDs, it is referenced by the markup <code>%entity-name;</code></li>
							<li>outside of DTDs, parameter entities cannot be used</li>
						</ul>
						<li>As general entities, parameter entities are meant for reuse</li>
						<ul>
							<li>in a DTD, reuse is mostly about reusing structures</li>
							<li>parameter entities are DTDs <q>duct tape</q>, not elegant, but effective</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XHTML Parameter Entities (Attributes)</title>
					<listing src="xhtml1-transitional.dtd" line="433-437"/>
					<listing src="xhtml1-transitional.dtd" line="188-188"/>
					<listing src="xhtml1-transitional.dtd" line="133-138"/>
					<listing src="xhtml1-transitional.dtd" line="145-149"/>
					<listing src="xhtml1-transitional.dtd" line="55-56"/>
					<listing src="xhtml1-transitional.dtd" line="193-193"/>
				</slide>
				<slide>
					<title>XHTML Parameter Entities (Content)</title>
					<listing src="xhtml1-transitional.dtd" line="433-437"/>
					<listing src="xhtml1-transitional.dtd" line="230-230"/>
					<listing src="xhtml1-transitional.dtd" line="227-227"/>
					<listing src="xhtml1-transitional.dtd" line="203-204"/>
					<listing src="xhtml1-transitional.dtd" line="200-201"/>
					<listing src="xhtml1-transitional.dtd" line="197-198"/>
					<listing src="xhtml1-transitional.dtd" line="222-222"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>DTD for XML Schemas</title>
				<ul>
					<li>XML documents are processed by applications</li>
					<li>Applications have assumptions about XML documents</li>
					<li>DTDs allow to formalize some of these constraints</li>
					<li>Part of the constraint checking must still be programmed</li>
				</ul>
			</slide>
			<slide>
				<title>Modeling DTDs</title>
				<ul>
					<li>Data models can be mapped to many different DTDs</li>
					<li>What is a good DTD? What is a bad DTD?</li>
					<li>How does the DTD affect further processing?</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xpath">
		<title short="XPath">XML Path Language (XPath)</title>
		<date>2013-09-16</date>
		<toc class="assignment"><a href="a/3/">A3</a>&#160;assigned (due&#160;date:&#160;10/1)</toc>
		<toc class="resources"><a href="http://www.w3.org/TR/xpath" title="W3C XPath 1.0 Specification">XPath&#160;1.0&#160;Spec</a>&#160;· <a href="xpath-chapter.pdf">XPath Chapter</a></toc>
		<toc class="abstract">XML structures data into a rather small number of different constructs, most notably elements and attributes. The <em>XML Path Language (XPath)</em> defines a way how to select parts of XML documents, so that they can be used for further processing. XPath's primary use in in <em>XSL Transformations (XSLT)</em>, but other XML technologies use it as well, e.g. XSD. XPath is a very compact language with a syntax that resembles path expressions well-known from file systems. These path expressions, however, are generalized and therefore much more powerful than the rather simple path expressions in file systems. Because of its use in different XML technologies, XPath is one of the most important XML core technologies.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Why XPath?</title>
			<slide>
				<title>Selecting Parts of XML Documents</title>
				<ul>
					<li>XML is a syntax for trees</li>
					<ul>
						<li>it defines a way for how trees can be exchanged</li>
					</ul>
					<li>XML technologies should provide support for working with trees</li>
					<ul>
						<li>when receiving trees, access to the tree should be easy (DOM)</li>
						<li>validating trees should be easy (<link href="xsd-1">XSD</link>)</li>
						<li>mapping trees should be easy (<link href="xslt-1">XSLT</link>)</li>
						<li>querying tree collections should be easy (<link href="xquery">XQuery</link>)</li>
						<li>XPath is what regular expressions for text-based information</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Making Selection Reusable</title>
				<ul>
					<li>Different XML technologies need selection</li>
					<ul>
						<li><link href="xslt-1">XSLT</link> needs it for selecting parts and manipulating them</li>
						<li><link href="xsd-1">XSD</link> needs it for applying identity constraints</li>
						<li>DOM needs it for extracting parts from an XML tree</li>
						<li>XQuery needs it for writing XML-oriented queries</li>
					</ul>
					<li>XPath was created to be reusable</li>
					<ul>
						<li>XML experts should only learn one selection language</li>
						<li>this knowledge can be reused when learning new technologies</li>
						<li>implementations can reuse code libraries</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>How XPath Evolved</title>
				<ul>
					<li>XSL was designed as the new XML stylesheet language</li>
					<ol>
						<li><link href="xslt-1">XSL Transformations (XSLT)</link> transform the input document</li>
						<li><em>XSL Formatting Objects (XSL-FO)</em> is what they will transform it to</li>
					</ol>
					<li>XSLT was designed to work on arbitrary XML input documents</li>
					<ul>
						<li>started as a part of XSL (<a href="http://www.w3.org/TR/1998/WD-xsl-19981216">WD-xsl-19981216</a> → <a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a>)</li>
						<li>for selecting parts of the transformation input, a selection mechanism had to be provided</li>
					</ul>
					<li>XPath was turned into a standalone specification</li>
					<ul>
						<li>started as a part of XSLT (<a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a> → <a href="http://www.w3.org/1999/07/WD-xslt-19990709">WD-xslt-19990709</a>)</li>
						<li>reused in a number of other W3C specifications (XSD, DOM)</li>
					<li>Complete overhaul for XSLT 2.0 and XQuery</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xpath20/">XPath 2.0</a> as the core language</li>
						<li>a much larger set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
						<li>the underlying <a href="http://www.w3.org/TR/xpath-datamodel/">data model</a> which describes the foundation</li>
					</ul>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>How XPath Works</title>
			<part id="xpath-tree">
				<title>The XPath Tree Model</title>
				<slide>
					<title>Starting from the Infoset</title>
					<ul>
						<li>XPath operates on an abstract data model</li>
						<ul>
							<li>a tree derived from the <link href="infoset"/></li>
							<li>a simplification (another one!) of the underlying XML</li>
						</ul>
						<li>The Infoset is turned into an <em>XPath node tree</em></li>
						<ul>
							<li>11 infoset item types → 7 XPath node tree node types</li>
							<li>character items are merged into text nodes</li>
							<li>namespace declarations are no longer visible as attributes</li>
						</ul>
					</ul>
				</slide>
				<slide id="not-xpath">
					<title>What is <u>Not</u> in the XPath Tree</title>
					<ul>
						<li>The same things which are <link href="not-infoset">not in the Infoset</link></li>
						<ul>
							<li>the order of attributes in a start tag</li>
							<li>the types of quotes around attribute values</li>
							<li>character references and entities (<code>&amp;#xFC;</code>/<code>&amp;uuml;</code> → <code>ü</code>)</li>
						</ul>
						<li>And some more …</li>
						<ul>
							<li>namespace declarations are no longer visible as attributes</li>
							<li>notations and unexpanded entity references</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part>
				<title>XPath Evaluation</title>
				<slide>
					<title>Tree In / Selection Out</title>
					<ul>
						<li>XPath evaluates an expression based on a tree</li>
						<li>Where the tree comes from is out of XPath's scope</li>
						<li>The result of the evaluation is a selection</li>
						<ul>
							<li><code>//img[not(@alt)]</code> → select all images which have no <code>alt</code> attribute</li>
							<li><code>count(//img)</code> → return the number of images</li>
							<li><code>/descendant::img[3]/@src</code> → return the third image's <code>src</code> URI</li>
							<li><code>starts-with(/html/@lang, 'en')</code> → test whether the document's language is english</li>
						</ul>
						<li>Syntax errors may occur</li>
						</ul>
				</slide>
			</part>
		</part>
		<part>
			<title short="Location Paths">XPath Location Paths</title>
			<slide>
				<title>Location Path Structure</title>
				<ul>
					<li>Each location path consists of <em>Location Steps</em></li>
					<ul>
						<li>location steps are separated by <q><code>/</code></q>, like path names in file systems</li>
					</ul>
					<li>Similarities between XPath location paths and file systems</li>
					<ol>
						<li>nodes in the <link href="xpath-tree">XPath tree</link> have different types</li>
						<li>the <link href="xpath-nodetest">type and number of nodes selected by one step</link></li>
						<li>the <link href="xpath-axes">direction in which each step moves</link></li>
						<li>additional <link href="xpath-predicates">filters for selecting specific nodes</link></li>
					</ol>
					<li>Differences between XPath location paths and file systems</li>
					<ol>
						<li>XPaths may return <link href="xpath-expressions">other data types than nodes</link></li>
						<li>XPath provides a <link href="xpath-functions">built-in function library</link></li>
					</ol>
				</ul>
			</slide>
			<part>
				<title short="Node Tests">XPath Node Tests</title>
				<slide>
					<title>File System vs. XPath Paths</title>
					<table style="margin : 5% ; " width="85%">
						<tr>
							<th>File System Path:</th>
							<td align="center"><code>/</code></td>
							<td align="center"><code>usr</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>local</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>apache</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>bin</code></td>
							<td align="center"><code>/</code></td>
						</tr>
						<tr>
							<th># Selected Nodes:</th>
							<td align="center">1</td>
							<td align="center">→ 1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">1</td>
						</tr>
					</table>
					<table style="margin : 5% ; " width="85%">
						<tr>
							<th>XPath:</th>
							<td align="center"><code>/</code></td>
							<td align="center"><code>html</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>body</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>table</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>thead</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>tr</code></td>
						</tr>
						<tr>
							<th># Selected Nodes:</th>
							<td align="center">1</td>
							<td align="center">→ 1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">6</td>
							<td align="center">→</td>
							<td align="center">4</td>
							<td align="center">→</td>
							<td align="center">12</td>
						</tr>
					</table>
				</slide>
				<slide id="xpath-nodetest">
					<title>Tests for Nodes</title>
					<ul>
						<li>Name tests</li>
						<ul>
							<li>testing for a particular name (elements/attributes): <code>/html/head/title</code></li>
							<li>wildcards (testing for any name): <code>/html/head/*</code></li>
						</ul>
						<li>Node type tests</li>
						<ul>
							<li>text nodes: <code>text()</code></li>
							<li>comment nodes: <code>comment()</code></li>
							<li>any nodes: <code>node()</code></li>
						</ul>
						<li>Processing instruction tests</li>
						<ul>
							<li>any PI: <code>processing-instruction()</code></li>
							<li>specific PI: <code>processing-instruction("xml-stylesheet")</code></li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xpath-axes">
				<title short="Axes">XPath Axes</title>
				<slide>
					<title>Where Do You Want to Go Today?</title>
					<ul>
						<li>File system paths are one direction only</li>
						<ul>
							<li>always one level down in the file system hierarchy</li>
							<li><code>.</code> and <code>..</code> are clever directory shortcuts</li>
							<li>other directions supported by tools (e.g., <code>find</code>)</li>
						</ul>
						<li>XPath allows steps is different directions</li>
						<ul>
							<li>the default direction is <code>child</code></li>
							<li>other directions are explicitly specified: <code>descendant::a</code></li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Axis Peculiarities</title>
					<ul>
						<li>Attributes and Namespaces are <u>not</u> the children of elements, but …</li>
						<li>… elements are their attributes' parent!</li>
						<ul>
							<li>very counter-intuitive</li>
							<li>very convenient</li>
						</ul>
						<li>Attributes and Namespaces are always leaves in the node tree</li>
						<li>Attribute nodes <u>have</u> the attribute value as their value</li>
						<li>Namespace nodes <u>have</u> the namespace name (i.e., a URI) as their value</li>
						<li>Namespace nodes exist because of namespace declarations</li>
						<ul>
							<li>in the XPath node tree, only the namespace nodes are visible</li>
							<li>the namespace declaration attributes (<code>xmlns</code>) are invisible</li>
							<li>one namespace declaration potentially creates many namespace nodes</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Axes</title>
					<img style="height : 75% ; margin : 2% ; " src="xpath-axes.png" title="XPath Axes"/>
				</slide>
				<slide>
					<title>Putting it all Together</title>
					<ul>
						<li>XPath location paths use a simple syntax</li>
						<ul>
							<li>sequence of location steps, separated by <q><code>/</code></q></li>
						</ul>
						<li>Each location step uses a simple structure (<code>preceding::p[@class="warning"]</code>)</li>
						<ol>
							<li>an axis followed by <q><code>::</code></q> (no axis uses the default axis <code>child</code>)</li>
							<li>a <link href="xpath-nodetest">node test</link></li>
							<li><em>0-n</em> <link href="xpath-predicates"/> enclosed in <q><code>[]</code></q></li>
						</ol>
						<li>Location paths can be abbreviated</li>
						<ul>
							<li><code>child::</code> can be omitted (default axis)</li>
							<li><code>attribute::</code> can be written as <q><code>@</code></q></li>
							<li><q><code>.</code></q> is an abbreviation for <code>self::node()</code></li>
							<li><q><code>..</code></q> is an abbreviation for <code>parent::node()</code></li>
							<li><q><code>//</code></q> is an abbreviation for <code>/descendant-or-self::node()/</code></li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xpath-predicates">
				<title>Predicates</title>
				<slide>
					<title>Location Step Filters</title>
					<ul>
						<li>Predicates are filters for each location step</li>
						<ul>
							<li>there can be any number of filters (<em>0-n</em>)</li>
							<li>each filter is applied to each selected node individually</li>
						</ul>
						<li>Each predicate is an XPath and evaluated as a boolean</li>					
						<ul>
							<li>the context of this evaluation is the node for which the filter is evaluated</li>
							<li>if the result is a number, it is compared with the <code>position()</code> function (<code>/descendant::a[5]</code>)</li>
						</ul>
						<li>Predicates always reduce the set of selected nodes</li>
						<ul>
							<li>as corner cases, the set of selected nodes does not change or is empty</li>
							<li>predicates are used in the majority of non-trivial XPath location paths</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Location Path Processing</title>
					<ul>
						<li>Location paths are processed in a very simple way</li>
						<ol>
							<li>start with a given context</li>
							<li>for each location step, repeat the following steps:</li>
							<li>based on the context and the axis, select the nodes on this axis</li>
							<li>reduce this selection to the nodes identified by the node test</li>
							<li>sequentially apply all filters to each of these nodes</li>
							<li>take the remaining node set as the context for the next location step</li>
						</ol>
					</ul>
				</slide>
			</part>
		</part>
		<part id="xpath-expressions">
			<title>XPath Expressions</title>
			<slide>
				<title>Beyond Location Paths</title>
				<ul>
					<li>XPath is a full expression language</li>
					<ul>
						<li>any evaluated expression in XSLT is an XPath</li>
						<li>XPath must be able to calculate operate on non-XML data types</li>
					</ul>
					<li>XPath uses a very simple data model</li>
					<ol>
						<li>node sets: <code>//img[not(@alt)]</code></li>
						<li>number: <code>count(//img)</code></li>
						<li>string: <code>/descendant::img[3]/@src</code></li>
						<li>boolean: <code>starts-with(/html/@lang, 'en')</code></li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>XPath Usages</title>
				<ul>
					<li>XPath is used in different technologies</li>
					<ul>
						<li>XSLT uses XPath as its expression language</li>
						<li>XSD uses XPath for selecting identity constraint nodes</li>
						<li>DOM uses XPath as a way to select DOM nodes</li>
					</ul>
					<li>Depending on the environment, expression must yield certain results</li>
					<ul>
						<li>for conditionals, a boolean must be returned</li>
						<li>iterations (in XSLT) only loop over nodes</li>
						<li>when printing out text, a string must be produced</li>
					</ul>
					<li>XPath has built-in rules for casting types</li>
					<ul>
						<li>node set → boolean: empty is false, non-empty is true</li>
						<li>node → string: take the <em>string value</em> (i.e., concatenate all text node descendants)</li>
						<li>string → number: interpret as decimal notation (otherwise return <q><code>NaN</code></q>)</li>
						<li>XPaths often return surprising results (<code>//a[starts-with(@href, https)]</code>)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="xpath-functions">
			<title>XPath Functions</title>
			<slide>
				<title>Function Library</title>
				<ul>
					<li>XPath has a small library of built-in functions</li>
					<ul>
						<li>useful for basic XPath-level functions</li>
						<li>other specs are allowed to extend it (XSLT does it)</li>
					</ul>
					<li>XPath functions return results of various data types</li>
					<ul>
						<li>boolean: <code>boolean, contains, false, lang, not, starts-with, true</code></li>
						<li>number: <code>ceiling, count, floor, last, number, position, round, string-length, sum</code></li>
						<li>string: <code>concat, local-name, name, namespace-uri, normalize-space, string, substring, substring-after, substring-before, translate</code></li>
						<li>node set: <code>id</code></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Using Functions</title>
				<ul>
					<li>Functions and location paths are orthogonal</li>
					<ul>
						<li>each construct may be based on the other</li>
						<li>it is possible to nest them arbitrarily</li>
						<li>predicates often contain functions</li>
						<pre>//a[substring(@href,string-length(@href)-2)='pdf']</pre>
					</ul>
					<li>XPaths can become powerful and complex</li>
					<ul>
						<li>writing some code or thinking about an XPath?</li>
						<li>XPaths are more declarative</li>
						<li>they may be more robust against changes in the XML schema</li>
						<li>they can be optimized by a smart XPath implementation</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Limitations of XPath</title>
			<slide>
				<title>XPath Selects</title>
				<ul>
					<li>Query languages select and recombine</li>
					<ol>
						<li>look up all addresses by zip code</li>
						<li>for each zip code, count the number of addresses</li>
					</ol>
					<li>XSLT fills in the missing parts (as a programming language)</li>
					<ul>
						<li>XSLT can construct XML and re-apply XPath</li>
					</ul>
					<li>XQuery fills in the missing parts (query-wise)</li>
					<ul>
						<li>80% of XQuery are XPath (in version 2.0, though)</li>
						<li>the remaining 20% are bindings, constructors, and glue</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XPath is Important</title>
				<ul>
					<li>XPath is a basic tool of the XML toolbox</li>
					<li>XPath is reused in various XML technologies</li>
					<li>XPath selects parts of an XML document</li>
					<li>XPath can do more general things by using expressions</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xpath20">
		<title short="XPath 2.0">XML Path Language (XPath) 2.0</title>
		<date>2013-09-18</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xpath20" title="W3C XPath 2.0 Specification">XPath&#160;2.0&#160;Spec</a></toc>
		<toc class="abstract">The <em>XML Path Language (XPath)</em> is one of the most useful and frequently used languages in the area of XML technologies. In its version 1.0, it is used in technologies such as XSLT, XSD, DOM, and XML Tools. With <em>XPath 2.0</em>, the language has been greatly extended, the new version of XPath is the foundation for XSLT 2.0 and XQuery. XPath 2.0 provides support for regular expression matching, typed expressions, and contains language constructs for conditional and repeated evaluation.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Why XPath?</title>
			<slide>
				<title>Selecting Parts of XML Documents</title>
				<ul>
					<li>XML is a syntax for trees</li>
					<ul>
						<li>it defines a way for how trees can be exchanged</li>
					</ul>
					<li>XML technologies should provide support for working with trees</li>
					<ul>
						<li>when receiving trees, access to the tree should be easy (DOM)</li>
						<li>validating trees should be easy (<link href="xsd-1">XSD</link>)</li>
						<li>mapping trees should be easy (<link href="xslt-1">XSLT</link>)</li>
						<li>querying tree collections should be easy (<link href="xquery">XQuery</link>)</li>
						<li>XPath is what regular expressions for text-based information</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Making Selection Reusable</title>
				<ul>
					<li>Different XML technologies need selection</li>
					<ul>
						<li><link href="xslt-1">XSLT</link> needs it for selecting parts and manipulating them</li>
						<li><link href="xsd-1">XSD</link> needs it for applying identity constraints</li>
						<li>DOM needs it for extracting parts from an XML tree</li>
						<li>XQuery needs it for writing XML-oriented queries</li>
					</ul>
					<li>XPath was created to be reusable</li>
					<ul>
						<li>XML experts should only learn one selection language</li>
						<li>this knowledge can be reused when learning new technologies</li>
						<li>implementations can reuse code libraries</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>How XPath Evolved</title>
				<ul>
					<li>XSL was designed as the new XML stylesheet language</li>
					<ol>
						<li><em>XSL Transformations (XSLT)</em> transform the input document</li>
						<li><em>XSL Formatting Objects (XSL-FO)</em> is what they will transform it to</li>
					</ol>
					<li>XSLT was designed to work on arbitrary XML input documents</li>
					<ul>
						<li>started as a part of XSL (<a href="http://www.w3.org/TR/1998/WD-xsl-19981216">WD-xsl-19981216</a> → <a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a>)</li>
						<li>for selecting parts of the transformation input, a selection mechanism had to be provided</li>
					</ul>
					<li>XPath was turned into a standalone specification</li>
					<ul>
						<li>started as a part of XSLT (<a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a> → <a href="http://www.w3.org/1999/07/WD-xslt-19990709">WD-xslt-19990709</a>)</li>
						<li>reused in a number of other W3C specifications (XSD, DOM)</li>
					</ul>
					<li>Complete overhaul for XSLT 2.0 and XQuery</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xpath20/">XPath 2.0</a> as the core language</li>
						<li>a much larger set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
						<li>the underlying <a href="http://www.w3.org/TR/xpath-datamodel/">data model</a> which describes the foundation</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>How XPath Works</title>
			<part>
				<title>The XPath Tree Model</title>
				<slide>
					<title>Starting from the Infoset</title>
					<ul>
						<li>XPath operates on an <link href="xpath-tree">abstract data model</link></li>
						<ul>
							<li>a tree derived from the <link href="infoset"/></li>
							<li>a simplification (another one!) of the underlying XML</li>
						</ul>
						<li>The Infoset is turned into an <em>XPath node tree</em></li>
						<ul>
							<li>11 infoset item types → 7 XPath node tree node types</li>
							<li>character items are merged into text nodes</li>
							<li>namespace declarations are no longer visible as attributes</li>
						</ul>
					</ul>
				</slide>
				<slide id="not-xpath">
					<title>What is <u>Not</u> in the XPath Tree</title>
					<ul>
						<li>The same things which are <link href="not-infoset">not in the Infoset</link></li>
						<ul>
							<li>the order of attributes in a start tag</li>
							<li>the types of quotes around attribute values</li>
							<li>character references and entities (<code>&amp;#xFC;</code>/<code>&amp;uuml;</code> → <code>ü</code>)</li>
						</ul>
						<li>And some more …</li>
						<ul>
							<li>namespace declarations are no longer visible as attributes</li>
							<li>notations and unexpanded entity references</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part>
				<title>XPath Evaluation</title>
				<slide>
					<title>Tree In / Selection Out</title>
					<ul>
						<li>XPath evaluates an expression based on a tree</li>
						<li>Where the tree comes from is out of XPath's scope</li>
						<li>The result of the evaluation is a selection</li>
						<ul>
							<li><code>//img[not(@alt)]</code> → select all images which have no <code>alt</code> attribute</li>
							<li><code>count(//img)</code> → return the number of images</li>
							<li><code>/descendant::img[3]/@src</code> → return the third image's <code>src</code> URI</li>
							<li><code>starts-with(/html/@lang, 'en')</code> → test whether the document's language is english</li>
						</ul>
						<li>Syntax errors may occur</li>
						</ul>
				</slide>
			</part>
		</part>
		<part>
			<title short="XPath 1.0">XPath 1.0 Revisited</title>
			<slide>
				<title>Source Document</title>
				<listing src="xlinked-class.xml" line="81-98" title="Web-Based Publishing Class – Spring 2007"/>
			</slide>
			<slide>
				<title>XPath Expressions</title>
				<ul>
					<li>XPaths can be location paths</li>
					<pre>//ul/li</pre>
					<li>XPaths can use functions</li>
					<pre>id('dret')</pre>
					<li>XPaths can be expressions yielding atomic values</li>
					<pre>substring-before(id('dret'), ' ')</pre>
					<li>XPaths can combine all of the above</li>
					<pre>count(//ul/li[starts-with(substring-after(., ' '), 'W')])</pre>
				</ul>
			</slide>
			<slide>
				<title>Axes</title>
				<img style="width : 86% ; margin : 4% ; " src="xpath-axes.png"/>
			</slide>
		</part>
		<part>
			<title>Ease of Use</title>
			<slide>
				<title>Easier to Understand</title>
				<ul>
					<li>XPath 2.0 provides better ways to write XPaths</li>
					<ul>
						<li>some constructs allow better ways of writing XPaths</li>
						<li>some constructs allow things previously impossible in XPath</li>
					</ul>
					<li>XPath usually is embedded in another language (XQuery, XSLT)</li>
					<ul>
						<li>even in XSLT 1.0, there was always a trade-off between XPath and XSLT</li>
						<li>with XPath 2.0, even more powerful XPaths can be implemented</li>
					</ul>
					<li>Finding a good balance between XPath and the host language is an art</li>
					<ul>
						<li>very complex XPaths can become almost undecipherable</li>
						<li>there is no final answer, coding styles vary based on language preference</li>
					</ul>
				</ul>
				<pre>&lt;listing src="xlinked-class.xml" line="81-98"/></pre>
				<pre>string-join(tokenize( if ( exists(@encoding) ) then unparsed-text($fileuri, @encoding) else unparsed-text($fileuri), '\r?\n')[(position() ge number(tokenize(current()/@line, '\-')[1])) and (position() le number(tokenize(current()/@line, '\-')[2]))], '&amp;#xa;')</pre>
			</slide>
			<part id="xpath20-conditional">
				<title>Conditional Expressions</title>
				<slide>
					<title>Control Flow in XPath</title>
					<ul>
						<li>XPath 1.0 expressions <q>control flow</q> is based on predicates</li>
						<ul>
							<li>the results of location path steps are filtered by predicates</li>
							<li>this can be used to <q>emulate</q> control flow</li>
							<li>this technique is limited because it can only be applied to nodes</li>
						</ul>
						<li>XPath 2.0 introduces conditional expressions</li>
						<ul>
							<li>a condition is given which is interpreted as a boolean</li>
							<li>based on the result, either the <xpath>then</xpath> or the <xpath>else</xpath> part is evaluated</li>
							<li>the else part may not be omitted</li>
						</ul>
					</ul>
					<pre>if ( … ) then … else …</pre>
					<pre>if ( @sex eq 'm' ) then 'Sir' else 'Madam'</pre>
					<pre>if ( @sex eq 'm' ) then 'Sir' else if ( @sex eq 'f' ) then 'Madam' else 'Whatever'</pre>
				</slide>
				<slide>
					<title>Less XSLT</title>
					<listing src="names.xml"/>
					<pre>first | last[not(../first)]</pre>
					<pre><![CDATA[<xsl:variable name="name">
	<xsl:choose>
		<xsl:when test="first">
			<xsl:value-of select="first"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="last"/>
		</xsl:otherwise>
	</xsl:choose>
</xsl:variable>]]></pre>
					<pre>if ( exists(first) ) then first else last</pre>
				</slide>
			</part>
			<part id="xpath20-iterations">
				<title>Iterations</title>
				<slide>
					<title>Repeating Expression Evaluation</title>
					<ul>
						<li>Iteration repeatedly applies an expression to a sequence of items</li>
						<ul>
							<li>the notion of <link href="xpath20-sequences"/> is central to this concept</li>
							<li>this requires variables for binding and evaluation</li>
						</ul>
						<li>Iterations clearly demonstrate the change in expressiveness</li>
						<ul>
							<li>they introduce functionality which previously was limited to host languages</li>
						</ul>
					</ul>
					<pre>for $… in … return …</pre>
					<pre>for $i in //name return $i/last</pre>
					<pre>for $i in //name return if ( exists($i/first) ) then $i/first else $i/last</pre>
				</slide>
				<slide>
					<title>Iterations vs. Location Paths</title>
					<ul>
						<li>Every location path can be written using iterations</li>
						<pre>/names/name/last</pre>
						<pre>for $i in /names return for $j in $i/name return $j/last</pre>
						<li>Iterations are a more generalized way of evaluation</li>
						<ul>
							<li>path expressions work on nodes only</li>
							<pre>for $i in 1 to 10 return $i</pre>
							<li>path expression sort by document order and eliminate duplicates</li>
							<pre>//last/../..</pre>
							<pre>for $i in //last return for $j in $i/.. return $j/..</pre>
							<li>location steps change the context, iterations use the variable for this purpose</li>
						</ul>
						<li>Location paths are a useful syntax and method for tree navigation</li>
					</ul>
				</slide>
			</part>
			<part id="xpath20-quantified">
				<title>Quantified Expressions</title>
				<slide>
					<title>Testing Sequences</title>
					<ul>
						<li>Testing whether some or all items of a sequence satisfy a condition</li>
						<ul>
							<li>the notion of <link href="xpath20-sequences"/> is central to this concept</li>
							<li>this requires variables for binding and evaluation</li>
						</ul>
						<li>Quantifiers are well-known from query languages</li>
						<ul>
							<li><xpath>some</xpath> iterates over items and succeeds after the first success</li>
							<li><xpath>every</xpath> iterates over items and fails after the first failure</li>
							<li>both constructs are good candidates for optimization</li>
						</ul>
					</ul>
					<pre>( some | every ) $… in … satisfies …</pre>
					<pre>some $i in //*[@xlink:type='locator']/@xlink:href satisfies $i eq $query-uri</pre>
					<pre>every $i in //li/@id satisfies //*[@xlink:type='locator'][@xlink:href=concat('#', $i)]</pre>
				</slide>
			</part>
		</part>
		<part id="xpath20-sequences">
			<title>Sequences</title>
			<slide>
				<title>Major Changes</title>
				<ul>
					<li>XPath 1.0 has a very simple data model</li>
					<ol>
						<li>node sets: <code>//img[not(@alt)]</code></li>
						<li>number: <code>count(//img)</code></li>
						<li>string: <code>/descendant::img[3]/@src</code></li>
						<li>boolean: <code>starts-with(/html/@lang, 'en')</code></li>
					</ol>
					<li>XPath 2.0 needs a more powerful model for its advanced functionality</li>
					<ul>
						<li>everything in XPath 2.0 is a sequence</li>
						<li>sequences can contain a mix of items of various types</li>
						<li>sequences cannot be nested (there are no sequences of sequences)</li>
					</ul>
				</ul>
				<pre>every $i in ( 11, 22, 33, 'string' ) satisfies string(number($i)) ne 'NaN'</pre>
			</slide>
			<slide>
				<title>Divide and Conquer</title>
				<ul>
					<li>Sequences are part of the <a href="http://dret.net/lectures/xml-fall08/xdm">XDM</a></li>
					<ul>
						<li>data models are separate entities from evaluation languages</li>
						<li>a data model can be reused in different evaluation languages</li>
					</ul>
					<li>XDM is far more complex than its predecessor, the Infoset</li>
					<ul>
						<li>XSD datatypes have been integrated into the data model</li>
						<li>Sequences allow more complex structures to exist</li>
					</ul>
					<li>Understanding the data model is key to understanding the language</li>
					<ul>
						<li>for simple XPaths, the mental model of XPath 1.0 works</li>
						<li>more advanced XPaths can only be understood when understanding XDM</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Applications</title>
			<slide>
				<title>Standalone</title>
				<ul>
					<li>XPath can be used in standalone XML tools</li>
					<ul>
						<li>editors provide XPath evaluation as <q>regular expressions for XML</q></li>
						<li>text-based searches in bigger XML documents are not a good idea</li>
					</ul>
					<li>Standalone tools are good for learning XPaths</li>
					<ul>
						<li>many tools support interactive evaluation</li>
						<li>seeing sequences visualized often is very helpful</li>
					</ul>
				</ul>
				<pre>for $i in ( 11, 22, 33, 'string' ) return ($i, number($i))</pre>
			</slide>
			<slide>
				<title>XQuery</title>
				<ul>
					<li><link href="xquery">XQuery</link> is built on top of XPath 2.0</li>
					<ul>
						<li>XPath allows constructing sequences based on documents</li>
						<li>XPath has no way of generating new document structures</li>
					</ul>
					<li>XQuery builds a query language around XPath</li>
					<ul>
						<li>the basic idea is to provide a language for constructing results from sequences</li>
						<li>~80% of the complexity of XQuery are in XPath 2.0</li>
					</ul>
				</ul>
				<pre ahref="http://www.stylusstudio.com/xquery_primer.html"><![CDATA[declare variable $firstName external;
<videos featuring="{$firstName}"> {
  let $doc := .
  for $v in $doc//video, $a in $doc//actors/actor
  where ends-with($a, $firstName) and $v/actorRef = $a/@id
  order by $v/year
  return
	<video year="{$v/year}"> { $v/title } </video> }
</videos>]]></pre>
			</slide>
			<slide>
				<title>XSLT 2.0</title>
				<ul>
					<li>XSLT 2.0 is based on <link href="xslt-1">XSLT 1.0</link> and built on top of XPath 2.0</li>
					<ul>
						<li>XPath allows constructing sequences based on documents</li>
						<li>XPath has no way of generating new document structures</li>
					</ul>
					<li>XSLT focuses on transformations rather than queries</li>
					<ul>
						<li><q>a query is a transformation is a query</q></li>
						<li>language preference is more a question of training and experience</li>
					</ul>
					<li>Many problems can be appropriately solved with both languages</li>
					<ul>
						<li>XQuery is favored by database people and by the big vendors</li>
						<li>XSLT 2.0 is favored by XML people who worked a lot with XSLT 1.0</li>
						<li>implementations could easily support both languages</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Easy Transition</title>
				<ul>
					<li>XPath 1.0 users can start using XPath 2.0 right away</li>
					<li>apart from a <a href="http://www.w3.org/TR/xpath20/#id-backwards-compatibility" title="XPath 2.0 Spec: Backwards Compatibility with XPath 1.0">few corner cases</a>, the results will be the same</li>
					<li>XPath 2.0 has a huge set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
					<li>XSD types can be used, values can be cast</li>
					<li>Regular expressions are supported for working with strings</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xmlpractice" external="xml-in-practice.pdf">
		<title>XML in Practice</title>
		<date>2013-09-23</date>
		<toc class="author">Eric Kansa</toc>
		<toc class="resources">...&#160;· ...</toc>
		<toc class="abstract">...</toc>
	</presentation>
</hotspot>