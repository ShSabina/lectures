<?xml version="1.0" encoding="UTF-8"?>
<?hotspot layout-path="hotspot/hotspot/layout" ?>
<?hotspot kilauea-path="hotspot/kilauea" ?>
<?hotspot layout="ischool" ?>
<hotspot xmlns="http://dret.net/xmlns/hotspot/1" xmlns:hotspot="http://dret.net/xmlns/hotspot/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dret.net/xmlns/hotspot/1 hotspot/hotspot/schemas/hotspot.xsd">
	<configuration>
		<link subsections="yes" bookmarks="yes" versions="xml-fall13.xml" home="./" help="quick" contents="./" glossary="http://dret.net/glossary/" author="http://dret.net/netdret/"/>
		<paths img="img" listing="src"/>
		<outline count-text=" [*]" count-depth="all"/>
		<hyperlink extra=""/>
		<extension file="html" link=""/>
		<counter separator=":&#160;"/>
		<kilauea xmlns="http://xmlns.sharpeleven.net/kilauea">
			<plugins>
				<touch/>
			</plugins>
		</kilauea>
	</configuration>
	<license uri="http://creativecommons.org/licenses/by/3.0/" short="CC 3.0">
		<div class="license">
			<p><a rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" src="hotspot/hotspot/layout/ischool/ischool/somerights20.png" border="0" height="31" width="88"/></a></p>
			<p><a class="outlink" rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/">This work is licensed under a CC<br/>Attribution 3.0 Unported License</a></p>
		</div>
	</license>
	<title short="XML Foundations"><a href="./" title="Course Homepage">XML Foundations</a><br/>Fall 2013 &#x2014; INFO 242 (CCN 41613)</title>
	<author short="E. Wilde" affiliation="UC Berkeley ISchool"><a href="http://dret.net/netdret/">Erik Wilde</a></author>
	<affiliation short="UC Berkeley ISchool"><a href="http://www.berkeley.edu/" title="University of California, Berkeley">UC Berkeley</a> <a href="http://ischool.berkeley.edu/" title="ISchool">School of Information</a></affiliation>
	<date short="Fall 2013">Fall Semester 2013</date>
	<copyright>2013 Erik Wilde</copyright>
	<categories>
		<category element="xml" class="xml" name="XML"/>
		<category element="elem" class="xml elem" name="XML Element"/>
		<category element="html" class="html" name="HTML"/>
		<category element="htmla" class="html" name="HTML Attribute"/>
		<category element="htmel" class="html elem" name="HTML Element"/>
		<category element="cssp" class="css" name="CSS Property"/>
		<category element="csss" class="css" name="CSS Selector"/>
		<category element="css" class="css" name="CSS"/>
		<category element="xlink" class="xml" name="XLink"/>
		<category element="xpathf" class="xpath" name="XPath Function"/>
		<category element="xpath" class="xpath" name="XPath"/>
		<category element="xslte" class="xslt elem" name="XSLT Element"/>
		<category element="xslta" class="xslt" name="XSLT Attribute"/>
		<category element="xslt" class="xslt" name="XSLT"/>
		<category element="xsde" class="xsd elem" name="XSD Element"/>
		<category element="xsda" class="xsd" name="XSD Attribute"/>
		<category element="xsd" class="xsd" name="XSD"/>
		<category element="xq" class="xq" name="XQuery"/>
		<category element="uri" class="uri" name="URI"/>
		<category element="http" class="http" name="HTTP"/>
		<category element="mime" class="mime" name="MIME"/>
		<category element="atom" class="atom" name="Atom"/>
	</categories>
	<toc name="toc.html">
		<table rules="all" cellspacing="0" cellpadding="5" width="100%">
			<thead>
				<tr>
					<th valign="bottom">Date</th>
					<th valign="bottom">Subject</th>
					<th valign="bottom">Slides</th>
					<th valign="bottom">Additional Resources</th>
					<!-- <th valign="bottom"><a href="a/">Assignments</a></th> -->
				</tr>
			</thead>
			<tbody>
				<hotspot:for-each-presentation>
					<tr class="vevent">
						<td align="right" valign="top"><hotspot:date/></td>
						<td valign="top">
							<hotspot:if-toc class="author">
								<span class="guest">Guest Lecture by <hotspot:toc class="author"/> : </span>
							</hotspot:if-toc>
							<b><span class="summary"><hotspot:title/></span><span class="toggle">:</span></b> <span class="toggle"><span class="description"><hotspot:toc class="abstract"/></span></span>
							<div style="display : none">
								<span class="dtstart"><hotspot:date/>T09:00</span>
								<span class="dtend"><hotspot:date/>T10:30</span>
								<span class="location">205 South Hall, UC Berkeley</span>
							</div>
						</td>
						<td align="center"><hotspot:presentation-link title="Lecture Slides"><hotspot:title form="short"/></hotspot:presentation-link> <span class="toggle"><hotspot:slides>(*&#160;Slides)</hotspot:slides></span></td>
						<td align="center"><hotspot:toc class="resources"/></td>
						<!-- <td align="center"><hotspot:toc class="assignment"/></td> -->
					</tr>
				</hotspot:for-each-presentation>
			</tbody>
		</table>
	</toc>
	<presentation id="intro">
		<title short="Introduction">Overview and Introduction</title>
		<date>2013-09-04</date>
		<toc class="resources"><a href="http://www.w3.org/Press/1998/XML10-REC">XML 1.0 Press Release</a>&#160;· <a href="http://www.tbray.org/ongoing/When/200x/2008/02/10/XML-People" title="Tim Bray: XML People">XML People</a></toc>
		<toc class="abstract">The <em>Extensible Markup Language (XML)</em> has been introduced in 1998 to enable content providers to publish their content on the Web in an application-specific format. HTML was considered as conveying not enough semantics, since its only purpose was (and is) the preparation of content for Web-based publishing. XML was the first step towards machine-readable data formats for the Web, a trend that since its invention has been taken to higher levels with the idea of the <em>Semantic Web</em>. XML appeared when the Web was in the steepest part of its success curve, and since then has taken over as the globally accepted format for the exchange of machine-readable structured data.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Varia</title>
			<slide id="dret-info">
				<title>About Me</title>
				<ul>
					<li>Erik Wilde exists on <a href="http://dret.net/netdret/">the Web</a>, <a href="https://twitter.com/dret" title="@dret">Twitter</a>, <a href="http://www.flickr.com/photos/dret/">Flickr</a>, and <a href="http://dret.typepad.com/dretblog/" title="dretblog">his blog</a></li>
					<li>Computer Science in <a href="http://www.tu-berlin.de/eng/" title="Technical University of Berlin (TUB)">Berlin</a>, Ph.D. in <a href="http://www.ethz.ch/index_EN" title="Swiss Federal Institute of Technology">Zürich</a></li>
					<li>Post-Doc at <a href="http://www.icsi.berkeley.edu/" title="International Computer Science Institute">ICSI</a>, Berkeley (1997/98)</li>
					<li>Various activities in Switzerland (1998-2006)</li>
					<ul>
						<li>teaching at <a href="http://www.ethz.ch/index_EN">ETH Zürich</a> and <a href="http://www.fhnw.ch/">FHNW</a></li>
						<li>working as independent consultant (training, courses, consulting)</li>
						<li>research in <a href="http://dret.net/projects/">various XML-related areas</a></li>
					</ul>
					<li>Professor at the <a href="http://ischool.berkeley.edu/">School of Information</a> (2006-11)</li>
					<ul>
						<li>Technical Director of the <a href="http://isd.ischool.berkeley.edu/">Information and Service Design (ISD) program</a></li>
					</ul>
					<li>Architect at <a href="http://www.emc.com/">EMC</a>'s <a href="http://web.emc.com/informationintelligence">Information Intelligence Group (IIG)</a> (since 2011)</li>
					<ul>
						<li>providing guidance and guidelines for IIG's RESTful SOA</li>
					</ul>
				</ul>
			</slide>
			<slide id="course-info">
				<title>About this Course</title>
				<ul>
					<li>Course Web page: <code><a href="./">http://dret.net/lectures/xml-fall13/</a></code></li>
					<li>All sources (XML/examples/images) <a href="https://github.com/dret/lectures/tree/master/xml-fall13">available at GitHub</a></li>
					<li>Course mailing list: <code><a href="mailto:xml-fall13@bspace.berkeley.edu">xml-fall13@bspace.berkeley.edu</a></code></li>
					<ul>
						<li>archived in the <a href="https://bspace.berkeley.edu/portal/site/9a83055f-77a0-4627-a276-ece16c98f8e2">bSpace</a> <a href="https://bspace.berkeley.edu/portal/site/9a83055f-77a0-4627-a276-ece16c98f8e2/page/a1285cb7-16ec-441b-8b81-efa4bbc03831">email archive</a></li>
					</ul>
					<li>Grading is based on assignments and final exam</li>
					<ul>
						<li>25% split evenly across all assignments (grading per team)</li>
						<li>25% final <q>project report</q> (graded individually)</li>
						<li>50% final exam (30min oral, taken/graded individually)</li>
					</ul>
				</ul>
			</slide>
			<slide id="slide-info">
				<title>About these Slides</title>
				<ul>
					<li>Generated from <a href="http://dret.net/projects/xslidy/">Hotspot</a> <a href="xml-fall13.xml">XML</a></li>
					<li>Designed for online presentation and use (lots of links!)</li>
					<ul>
						<li>for printing, use <q>a</q> (all slides), and then <q>s</q> (smaller font) a couple of times</li>
					</ul>
					<li>A good real-world example for XML applications</li>
					<ul>
						<li>Slidy/Kilauea is useful, but there is no support for structures and hyperlinking</li>
						<li>Hotspot adds these features by adding an XSLT transformation</li>
						<li>Hotspot is useful, but there is no interface (XML editing only)</li>
					</ul>
				</ul>
			</slide>
			<slide id="resource-info">
				<title>Additional Resources</title>
				<ul>
					<li><a href="http://dret.net/biblio/">Bibliography at <code>http://dret.net/biblio/</code></a></li>
					<ul>
						<li>suggestions, updates, corrections are very welcome (really!)</li>
					</ul>
					<li>The <a href="http://www.w3.org/"><em>World Wide Web Consortium (W3C)</em></a></li>
					<ul>
						<li>the organization which invented XML</li>
						<li>as well as (almost) all other technologies covered in this course</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="why-xml">
			<title>Why/How/Where XML is Useful</title>
			<slide>
				<title>XML is a Metalanguage</title>
				<ul>
					<li>XML can be used to represent any kind of structured data</li>
					<ul>
						<li>(as long as the data is modeled in a way that fits XML's metamodel)</li>
					</ul>
					<li>XQuery and XSLT can be used to process XML documents</li>
					<ul>
						<li>(or use the language of your choice and XML libraries)</li>
					</ul>
					<li>XML formats can be designed to be flexible and extensible</li>
					<ul>
						<li>(this requires good modeling skills <em>and</em> good XML skills)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>GPS Track Visualization</title>
				<img src="marin-run-map.png" style="height : 70% ; margin : 2% ; " href="http://app.strava.com/activities/18200957"/>
			</slide>
			<slide>
				<title>GPS Track in XML</title>
				<ul>
					<li><a href="http://app.strava.com/activities/39586316">GPS data</a> exported to <a href="http://www.topografix.com/gpx/1/1/">GPX format</a></li>
				</ul>
				<listing src="2010-01-15-1.gpx" line="1-21"/>
			</slide>
			<slide>
				<title>GPS Track Combination</title>
				<img src="heatmap-golden-gate.png" style="height : 70% ; margin : 2% ; " href="http://x.raceshape.com/heatmap/view.html?id=r1ycR0%2Fhp88VjX%2FAVO4B3gHo%2B9gyzOuMQA1uDqCn"/>
			</slide>
			<slide>
				<title>Finding Activities (Oxygen)</title>
				<listing src="find-by-location-oxygen.xq"/>
			</slide>
		</part>
		<part>
			<title>Data Formats? Databases?</title>
			<part>
				<title>Alternatives to XML</title>
				<slide id="xml-and-csv">
					<title>XML and CSV</title>
					<ul>
						<li>CSV is easier to understand and use</li>
						<li>CSV tools (such as <em>Excel</em>) are widely used and understood</li>
						<li>Structures beyond tables are hard to represent</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
				<slide id="xml-and-json">
					<title>XML and JSON</title>
					<ul>
						<li>JSON maps better into most programming languages</li>
						<li>JSON objects can be readily used as language objects</li>
						<li>Structures beyond nested objects/arrays are hard to represent</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
				<slide id="xml-and-rdf">
					<title>XML and RDF</title>
					<ul>
						<li>RDF does not have the built-in <q>tree bias</q> of XML</li>
						<li>RDF can be combined more easily across <q>documents</q></li>
						<li>Data that has some <q>natural coherence</q> is hard to manage</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
			</part>
			<part>
				<title>XML Big Data</title>
				<slide>
					<title>XML and Databases</title>
					<ul>
						<li>A data format defines a framework for certain kinds of data</li>
						<ul>
							<li>some formats are <em>metalanguages</em> such as XML, but most are not</li>
						</ul>
						<li>A database is based on a <em>data model</em> and manages data as well as access</li>
						<li>XML does not talk about databases at all</li>
						<li>It is possible to build databases that support XML's model</li>
						<ul>
							<li>data storage can be scaled beyond what filesystems can manage</li>
							<li>access to XML can be much better optimized in XML databases</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XQuery using Files</title>
					<img style="width : 86% ; margin : 4% ; " src="xquery-overview-filesystem.png" title="File-based XQuery Processing"/>
				</slide>
				<slide>
					<title>XQuery using an XML Database</title>
					<img style="width : 86% ; margin : 4% ; " src="xquery-overview-dbms.png" title="DB-based XQuery Processing"/>
				</slide>
				<slide>
					<title>Moving Data into a Database</title>
					<img src="xDB-import.png" style="height : 70% ; margin : 2% ; " href="http://developer.emc.com/docs/documentum/xdb/manual/index.html#doc:task/adminclient_importing_data.html"/>
				</slide>
				<slide>
					<title>Finding Activities (xDB)</title>
					<listing src="find-by-location-xdb.xq"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XML is a Hammer</title>
				<ul>
					<li>XML is just one way to represent structured data</li>
					<li>Like all models/metamodels, XML has limitations and side-effects</li>
					<li>XML's tool chain allow to adapt to a variety of scenarios</li>
					<li>XML databases support scalable access to <q>XML Big Data</q></li>
					<li>As with all tools: know the tool, know the alternatives</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="basics">
		<title short="Basics">XML Basics</title>
		<date>2013-09-09</date>
		<toc class="resources"><a href="http://www.w3.org/TR/REC-xml/" title="W3C XML 1.0 Specification">XML&#160;1.0&#160;Spec</a>&#160;· <a href="http://dret.net/netdret/docs/wilde-cacm2008-xml-fever.html" title='Erik Wilde and Robert J. Glushko, "XML Fever", Communications of the ACM, 51(7):40-46, July 2008'>XML&#160;Fever</a></toc>
		<toc class="abstract">The <em>Extensible Markup Language (XML)</em> defines a simple way for structuring data. The power and popularity of XML can be explained by its versatility, the platform-independence, the standards and technologies leveraging it, and the number of tools and products supporting it. Understanding XML itself is rather simple, as it only depends on a very small set of other technologies. Unicode is the most important foundation of XML. XML itself specifies two different things: on the one hand the format for structured data, which are called <em>XML documents</em>, and on the other hand a constraint language for XML documents, which is called <em>Document Type Definition (DTD)</em>.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Foundations for XML</title>
			<slide>
				<title>Identifications</title>
				<ul>
					<li>Identification of Character Encodings</li>
					<ul>
						<li>text can be encoded using different character sets and encodings</li>
						<li>IANA maintains the <a href="http://www.iana.org/assignments/character-sets">official list of character encodings</a></li>
						<li>character encoding is about <em>characters</em>, not about <em>text</em></li>
					</ul>
					<li>Identification of Languages</li>
					<ul>
						<li>textual content should be tagged with language information</li>
						<li>specification based on <a href="http://www.loc.gov/standards/iso639-2/langhome.html">ISO 639 language tags</a></li>
						<li>language identification is about <em>text</em>, not about <em>characters</em></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XML's Idea of Content and Names</title>
				<p>XML documents can use a wide array of characters. They are defined by <a href="http://www.unicode.org/">Unicode</a>, which currently (Version 5.0) defines more than 100'000 characters (#100'000 added in 2005).</p>
				<listing src="japanese1.xml"/>
				<listing src="japanese2.xml"/>
			</slide>
			<slide>
				<title>XML and Unicode</title>
				<ul>
					<li>XML is based on Unicode</li>
					<ul>
						<li>XML is defined in terms of <a href="http://www.w3.org/TR/xml/#sec-starttags">character structures</a></li>
						<li>how these characters are encoded is not part of XML</li>
					</ul>
					<li>How are XML documents encoded?</li>
					<ul>
						<li>applications can use any character encoding they like</li>
						<li>XML processors <em>must</em> support UTF-8 and UTF-16</li>
						<li>XML processors <em>may</em> support any number of additional encodings</li>
					</ul>
					<li>How is the encoding <q>encoded</q>?</li>
					<ul>
						<li>part of the XML document: <code>&lt;?xml version="1.0" encoding="UTF-8"?></code></li>
						<li>bootstrap problem solved heuristically or by out-of-band information</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>XML</title>
			<slide>
				<title>XML Use Cases</title>
				<ul>
					<li>XML is a metalanguage supporting application-specific vocabularies</li>
					<li><em>RSS</em> (and <em>Atom</em>) are XML vocabularies for newsfeeds</li>
					<ul>
						<li><a href="http://docordie.blogspot.com/">Doc or Die</a>: <a href="http://docordie.blogspot.com/rss.xml">RSS feed</a> vs. <a href="http://docordie.blogspot.com/atom.xml">Atom feed</a></li>
						<li>browsers now incorporate and/or integrate newsfeed readers</li>
					</ul>
					<li><em>OpenDocument (ODF)</em> is a language for office application documents</li>
					<ul>
						<li>designed for open and interoperable exchange</li>
						<li>standardized by ISO (which now also standardizes Microsoft's <em>Open XML</em>)</li>
					</ul>
					<li><em>Scalable Vector Graphics (SVG)</em> for portable vector graphics</li>
					<ul>
						<li>designed for embedding in Web pages</li>
						<li>good example for compound documents: <a href="http://www.carto.net/papers/svg/animated_weather_symbols/">HTML containing SVG</a></li>
					</ul>
				</ul>
			</slide>
			<part>
				<title>XML Documents</title>
				<slide>
					<title>Markup?</title>
					<ul>
						<li>Structures are encoded using special characters</li>
						<ul>
							<li>a fundamental difference when comparing to binary formats</li>
							<li>markup languages can be read and modified using text-based tools</li>
							<li>programs must treat markup characters in a special way</li>
						</ul>
						<li>Documents are content interspersed with markup (i.e., structures)</li>
						<ul>
							<li>XML-aware software interprets the markup</li>
							<li>XML-unaware software just sees a text file</li>
							<li>modifications must be made XML-aware (e.g., inserting <q>AT&amp;T</q> as <q>AT&amp;amp;T</q>)</li>
						</ul>
						<li>You have to pay the <link href="markup-price"/></li>
					</ul>
				</slide>
				<slide>
					<title>Basic Concepts</title>
					<ul>
						<li>XML Documents have an <em>XML declaration</em> (optional)</li>
						<li>There is exactly one <em>document element</em> (a.k.a. <em>root element</em>)</li>
						<li>Elements may be nested (there is no conceptual limit)</li>
						<ul>
							<li>elements may be repeated (they can be identified by position)</li>
						</ul>
						<li>Elements are marked up using <em>tags</em></li>
						<ul>
							<li>most elements have content, surrounded by <em>start</em> and <em>end tags</em></li>
							<li>empty elements are allowed and may use a special notation</li>
						</ul>
						<li>Elements may have attributes (zero to any number)</li>
						<ul>
							<li>attributes can only occur once on an element (i.e., they cannot be repeated)</li>
						</ul>
					</ul>
					<listing src="my-first.xml"/>
				</slide>
				<slide id="xmltree">
					<title>Tree Syntax</title>
					<ul>
						<li>Markup is important, but only a notation</li>
						<li>XML documents are trees with different node types</li>
						<ul>
							<li>nodes so far: document, element, attribute, text</li>
						</ul>
						<img style="width : 90% ; margin : 4% ;" src="document-tree.png" title="XML document tree"/>
					</ul>
				</slide>
				<slide id="xmlelements">
					<title>Elements</title>
					<ul>
						<li>Elements can use a <a href="http://www.w3.org/TR/xml/#NT-Name">wide variety of names</a></li>
						<ul>
							<li>Allowed: <elem>html</elem>, <elem>id9832798472</elem>, <elem>_</elem>, <elem>:</elem>, <elem>こんにちは</elem></li>
							<li>Disallowed: leading numbers, spaces, control characters</li>
						</ul>
						<li>Element names usually convey some information about the content</li>
						<ul>
							<li>this is not reliable and highly language-dependent</li>
							<li>it is <em>very useful</em> when working with a known vocabulary</li>
							<li>it is <em>potentially harmful</em> when working with an unknown vocabulary</li>
						</ul>
						<li>Elements are the foundation for XML's versatility</li>
						<ul>
							<li>they can be nested (<code>&lt;address>&lt;city>Berkeley&lt;/city>&lt;zip>94709&lt;/zip>…</code>)</li>
							<li>they can be repeated (<code>&lt;givenname>Erik&lt;/givenname>&lt;givenname>Thomas&lt;/givenname></code>)</li>
							<li>their sequence can convey additional information (given names have a sequence)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Attributes</title>
					<ul>
						<li>Additional information pertaining to elements</li>
						<li>Traditionally, anything that is not considered <q>content</q></li>
						<ul>
							<li>SGML is a document markup language</li>
							<li>XML uses SGML's concepts</li>
							<li>XML has its roots in the document world</li>
						</ul>
						<li>Elements: Content (i.e., Data); Attributes: Metadata</li>
						<li>Documents often distinguish by what is textual content</li>
					</ul>
					<listing src="section.xml" line="12-20"/>
				</slide>
				<slide>
					<title>Attribute Syntax</title>
					<ul>
						<li>Naming rules are the same as for <link href="xmlelements"/></li>
						<li>Attributes always appear within an element's <em>start tag</em></li>
						<li>Attributes are <a href="http://www.w3.org/TR/xml/#NT-Attribute">name/value-pairs</a></li>
						<ul>
							<li>the value is enclosed in single or double quotes</li>
						</ul>
						<li>Attribute with a single-quote value: <elem>elem attr="Single: '"/</elem></li>
						<li>Attribute with a double-quote value: <elem>elem attr='Double :"'/</elem></li>
						<li>How can attribute values contain both?</li>
					</ul>
				</slide>
				<slide id="markup-price">
					<title>The Price for Markup</title>
					<ul>
						<li>Markup characters have a special meaning</li>
						<ul>
							<li><q>&lt;</q> opens a tag</li>
							<li>for attribute values, quotes delimit the value</li>
						</ul>
						<li>The literal use of a markup character requires escaping</li>
						<ul>
							<li>XML's <em>entities</em> can refer to pieces of content</li>
							<li>entity syntax is <code>&amp;name;</code> for referring to the entity <q><code>name</code></q></li>
							<li>XML has 5 <a href="http://www.w3.org/TR/xml/#sec-predefined-ent">predefined entities</a>: <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, <code>&amp;apos;</code>, <code>&amp;quot;</code></li>
						</ul>
						<li>Attribute using both kinds of quotes: <code>&lt;elem attr="Single ' and Double &amp;quot;"/></code></li>
					</ul>
					<pre><![CDATA[<li>Attribute using both kinds of quotes: <code>&lt;elem attr="Single ' and Double &amp;quot;"/></code></li>]]></pre>
				</slide>
				<slide id="mixed-content">
					<title>Mixed Content</title>
					<p>The term <em>Mixed content</em> in XML refers to elements <a href="http://www.w3.org/TR/xml/#sec-mixed-content">which have text content mixed with elements</a>. What these elements do depends on the elements <img style="height : 1em" src="smiley.gif"/>, but the important point is that they are on the same level as the text nodes of the mixed content.</p>
					<pre><![CDATA[<p>The term <em>Mixed content</em> in XML refers to elements <a href="http://www.w3.org/TR/xml/#sec-mixed-content">which have text content mixed with elements</a>. What these elements do depends on the elements <img style="height : 1em" src="smiley.gif"/>, but the important point is that they are on the same level as the text nodes of the mixed content.</p>]]></pre>
					<img style="width : 90% ; margin : 4% ;" src="mixed-content.png" title="XML tree for mixed content"/>
				</slide>
				<slide>
					<title>Mixed Content Usage</title>
					<ul>
						<li>Database people find mixed content irritating</li>
						<ul>
							<li>cannot be easily mapped to relational structures</li>
							<li>is more <em>document-like</em> than <em>data-like</em></li>
							<li>much harder to optimize for query analysis and query processing</li>
						</ul>
						<li>Document people find mixed content very intriguing</li>
						<ul>
							<li>textual content can still be used as simple text</li>
							<li>markup provides additional information for rich text</li>
							<li>start with a text-only document and use markup to add structure to it</li>
						</ul>
					</ul>
				</slide>
				<slide id="whitespace">
					<title>Whitespace</title>
					<ul>
						<li>XML documents often are pretty-printed</li>
						<li><em>Whitespace text nodes</em> often are <q>not really content</q></li>
						<ul>
							<li>XML whitespace characters are <em>space</em>, <em>tab</em>, <em>newline</em>, and <em>carriage return</em></li>
							<li>whitespace text nodes are text nodes containing <em>only</em> whitespace characters</li>
						</ul>
						<img style="width : 90% ; margin : 4% ;" src="document-tree-whitespace.png" title="XML tree with whitespace text nodes"/>
					</ul>
				</slide>
				<slide>
					<title>Significant Whitespace</title>
					<ul>
						<li>Some whitespace text nodes are relevant</li>
						<li>Usually text nodes in <em>mixed content</em> elements</li>
					</ul>
					<p>Whitespace <i>can be</i> <u>very</u> <b>important</b>!</p>
					<pre><![CDATA[<p>Whitespace <i>can be</i> <u>very</u> <b>important</b>!</p>]]></pre>
					<img style="height : 40% ; margin : 2% ;" src="significant-whitespace.png" title="XML tree containing significant whitespace"/>
				</slide>
			</part>
			<part id="wellformed">
				<title>Processing XML</title>
				<slide>
					<title>Observing XML Syntax</title>
					<ul>
						<li>XML's syntax requires you to use the right characters</li>
						<ul>
							<li><a href="http://www.w3.org/TR/xml/#NT-element">the grammar alone</a> allows many XML errors</li>
							<li><a href="http://www.w3.org/TR/xml/#GIMatch">additional constraints</a> ensure that everything is used correctly</li>
						</ul>
						<li><em>XML processors</em> (a.k.a. <em>XML parsers)</em> check for these rules</li>
						<ul>
							<li>if there are problems, the document cannot be interpreted as XML</li>
							<li>otherwise, the document is said to be <em>well-formed</em></li>
						</ul>
						<li>Only well-formed documents can be regarded as a tree</li>
						<ul>
							<li>other documents are not XML at all, even though they may be close</li>
							<li>XML processors must report problems to the application (no guessing allowed)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Validity</title>
					<ul>
						<li><em>Well-formed documents</em> observe XML rules</li>
						<ul>
							<li>they observe the XML syntax</li>
							<li>they observe all well-formedness constraints</li>
						</ul>
						<li>Applications require the right elements and attributes</li>
						<li><em>Validity</em> is a more comprehensive concept</li>
						<li><em>Valid documents</em> observe additional rules</li>
						<ul>
							<li>they must be well-formed documents</li>
							<li>they must adhere to the constraints defined in a schema (DTD, XSD, RNG, ...)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Semantics</title>
					<ul>
						<li>XML is a language for encoding trees</li>
						<ul>
							<li>Elements and attributes are labeled node in this tree</li>
							<li>the labels can be chosen freely by document authors</li>
						</ul>
						<li>The tree's meaning is nothing XML is concerned with</li>
						<ul>
							<li>peers must have a mutual understanding of the semantics</li>
							<li>XML without mutual understanding is almost useless</li>
							<li>reverse engineering often is possible, but it is risky and brittle</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XML Documents</title>
				<ul>
					<li>XML documents are structured data using markup</li>
					<li>Elements and Attributes are the main structuring mechanisms</li>
					<li>Elements and Attributes have names, but have no inherent semantics</li>
					<li>For using XML successfully, <em>shared semantics</em> are essential</li>
					<li>Always think about semantics</li>
				</ul>
			</slide>
		</part>		
	</presentation>
	<presentation id="dtd">
		<title short="DTD">Document Type Definition (DTD)</title>
		<date>2013-09-11</date>
		<toc class="abstract">The XML specification defines a format for structured data (XML documents) and a grammar-based constraint language for these (DTD). In SGML-based systems, DTDs were often very complex and feature-rich constructs, which controlled a lot of the processing of SGML documents. XML greatly simplified DTDs, and de-facto usage of DTDs today simplified them even more. In many systems today, DTDs are not used at all or generated from sample documents. In this lecture, it is argued that DTDs (or schemas, to be more general) should be taken seriously in any non-trivial XML application, because they are a representation of the underlying (and often underspecified) data model of the application.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Schema Languages</title>
			<slide>
				<title>XML Validation</title>
				<ul>
					<li>XML knows two <q>types</q> of documents, <em>well-formed</em> and <em>valid</em></li>
					<li><em>well-formed</em> documents satisfy all basic constraints of the XML specification</li>
					<ul>
						<li>they can be parsed according to the XML grammar</li>
						<li>they satisfy the additional constraints (e.g., start and end tags match)</li>
						<li>together, this means they can be translated into a <link href="xmltree">tree</link></li>
						<li>this tree then can be processed with XML tools (<link href="sax">SAX</link>, <link href="dom">DOM</link>, <link href="xslt-1">XSLT</link>, …)</li>
					</ul>
					<li><em>valid</em> documents must satisfy the constraints of a DTD</li>
					<ul>
						<li>a document must be well-formed before it can be validated</li>
						<li>all elements and attributes have been defined</li>
						<li>elements and attributes are used according to their definition</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Validation and Applications</title>
				<img src="valid-documents.png" style="width : 90% ; margin : 4% ; "/>
			</slide>
			<slide>
				<title>Non-XML, Well-Formed, and Valid</title>
				<listing src="non.xml" line="3-9"/>
				<listing src="address-invalid.xml" line="3-9"/>
				<listing src="address-valid.xml" line="3-9"/>
			</slide>
			<slide>
				<title>DTD Example</title>
				<listing src="address-valid.xml" line="1-2"/>
				<listing src="address.dtd"/>
				<ul>
					<li>The DTD defines constraints on element and attribute usage</li>
					<li>The DTD does only in part constrain textual contents</li>
				</ul>
			</slide>
			<slide>
				<title>XML Schema Languages</title>
				<ul>
					<li>DTDs are part of XML itself</li>
					<ul>
						<li>XML specifies the document format <u>and</u> one schema language</li>
						<li>DTD support is provided by most XML processors (<a href="http://www.w3.org/TR/REC-xml/#proc-types" title="XML specification">validating processors</a>)</li>
					</ul>
					<li>Other schema languages are available</li>
					<ul>
						<li><link href="xsd-1">XSD</link> as the W3C's recommendation</li>
						<li><a href="http://www.schematron.com/">Schematron</a> as a rule-based alternative</li>
						<li>various <a href="http://dret.net/glossary/xmlschemalanguage" title="XML glossary">other research projects and products</a></li>
					</ul>
					<li>Choosing appropriate schema language(s) is important</li>
					<ul>
						<li>we look at DTDs because they are part of XML itself</li>
						<li>we look at XSD because it is widely used</li>
						<li>Schematron is interesting because it is simple and powerful</li>
						<li>you may even invent your own schema language (a.k.a. <em>meta-programming</em>)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>DTD Basics</title>
			<slide>
				<title>XML is <q>SGML light</q></title>
				<ul>
					<li>XML is a subset of SGML</li>
					<ul>
						<li>XML documents have been greatly simplified</li>
						<li>XML DTDs have retained some of SGML's peculiarities</li>
					</ul>
					<li>DTD design should be left to XML experts</li>
					<ul>
						<li>simple DTDs (for prototypes) are easy to define (or generate)</li>
						<li>serious DTDs for complex data models are hard to define</li>
					</ul>
					<li>XML is a useful tool for experiments and prototypes</li>
					<ul>
						<li>basic knowledge of DTDs is required</li>
						<li>serious XML schemas often use <link href="xsd-1">XSD</link> anyway</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Associating Documents and DTDs</title>
				<ul>
					<li>A DTD is a schema for a set of documents</li>
					<ul>
						<li>there may be just one document for a DTD, there may be billions (HTML)</li>
						<li>in most cases, DTDs are managed as a separate resource</li>
					</ul>
					<li>The <a href="http://www.w3.org/TR/xml#sec-prolog-dtd"><em>Document Type Declaration</em></a> <q>contains or points to markup declarations that provide a grammar for a class of documents</q></li>
					<ul>
						<li>the part which is contained is called <em>Internal Subset</em></li>
						<li>the part which is pointed to is called <em>External Subset</em></li>
						<li>internal and external subset together are the <em>Document Type Definition (DTD)</em></li>
					</ul>
					<li>External subsets are identified by <em>Public</em> and <em>System Identifiers</em></li>
					<ul>
						<li><em>public identifiers</em> use a special notation</li>
						<li><em>system identifiers</em> are URIs (relative or absolute)</li>
						<li>applications use (i.e., know or retrieve) the DTD for validation</li>
					</ul>
				</ul>
				<listing src="address-valid.xml" line="1-2"/>
			</slide>
			<part>
				<title>DTD Syntax</title>
				<slide>
					<title>DTDs are not XML Documents</title>
					<ul>
						<li>DTDs use a special syntax</li>
						<ul>
							<li>somewhat ironic when everything else is XMLized</li>
							<li>DTDs cannot be processed with standard XML tools</li>
							<li>more compact than XML syntax</li>
						</ul>
						<li>Definition of elements and attribute lists</li>
						<ul>
							<li>elements are defined by the content they allow</li>
							<li>attribute lists are sets of allowed attributes on elements</li>
						</ul>
					</ul>
					<listing src="address.dtd"/>
				</slide>
				<slide>
					<title>Syntax Rules</title>
					<ul>
						<li>There is no container containing the whole DTD</li>
						<ul>
							<li><code>&lt;!ELEMENT example EMPTY></code> thus is a complete DTD</li>
						</ul>
						<li>Definitions (officially called <em>declarations</em>) use <code>&lt;!… ></code> syntax</li>
						<ul>
							<li><code>ELEMENT</code> is used to <link href="dtd-element">define an element</link></li>
							<li><code>ATTLIST</code> is used to <link href="dtd-attlist">define an attribute list</link></li>
							<li><code>ENTITY</code> is used to <link href="dtd-entity">define an entity</link></li>
						</ul>
						<li>The document element is not marked explicitly</li>
						<ul>
							<li>but it must be declared in the document type declaration</li>
							<li>this means the document element is established by the document, not by the DTD</li>
						</ul>
					</ul>
				<listing src="address-valid.xml" line="1-3"/>
				</slide>
			</part>
			<part id="dtd-element">
				<title>Defining Elements</title>
				<slide id="element-only-declaration">
					<title>Element Only Content</title>
					<ul>
						<li>Element content is defined by a grammar for the children</li>
						<ul>
							<li>sequences are indicated with a comma: <q><code>,</code></q></li>
							<li>choices are indicated with a vertical bar: <q><code>|</code></q></li>
							<li>optional parts are indicated with a question mark: <q><code>?</code></q></li>
							<li>repeatable parts are indicated with a plus: <q><code>+</code></q></li>
							<li>optional and repeatable parts are indicated with a asterisk: <q><code>*</code></q></li>
							<li>parentheses can be used for grouping and nesting</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="1064-1074"/>
				</slide>
				<slide id="mixed-content-declaration">
					<title>Mixed Content</title>
					<ul>
						<li><link href="mixed-content"/> allows text content and elements to be mixed</li>
						<ul>
							<li><link href="whitespace"/> characters are allowed in <link href="element-only-declaration"/> (this must not be declared)</li>
							<li>for non-whitespace characters, character data must be allowed explicitly</li>
						</ul>
						<li>The allowed child elements may be constrained, but not their order or their number of occurrences</li>
						<li>Mixed Content always is defined as <code>&lt;!ELEMENT x (#PCDATA | a | b | …)* ></code></li>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="568-568"/>
					<ul>
						<li><em>Character only</em> content is a special case of mixed content</li>
						<ul>
							<li>the element may only contain characters (no other elements)</li>
							<li>the repetition is not necessary because there is no choice</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="355-355"/>
				</slide>
				<slide>
					<title>Empty Content</title>
					<ul>
						<li>Empty elements can be useful</li>
						<ul>
							<li>they may contain all information in attributes</li>
							<li>their presence may carry semantics without the need for additional information</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="833-848"/>
				</slide>
			</part>
			<part id="dtd-attlist">
				<title>Defining Attribute Lists</title>
				<slide>
					<title>Attributes belong to Elements</title>
					<ul>
						<li>Attributes are specified in an element's <em>Attribute List</em></li>
						<ul>
							<li>an element definition may have any number of attributes associated with it</li>
							<li>attributes may occur at most once on an element</li>
						</ul>
						<li>Attributes definitions have a <em>name</em>, a <em>type</em>, and a <em>default declaration</em></li>
						<ul>
							<li>the attribute appears according to the default declaration</li>
							<li>if the attribute is present, its value must conform to the type</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="794-801"/>
				</slide>
				<slide id="dtd-attr-type">
					<title>Attribute Types</title>
					<ul>
						<li>Attribute values can be constrained (which is not possible for element content)</li>
						<ul>
							<li><code>CDATA</code> means any character string (but no markup)</li>
							<li>enumerated types list allowed values: <code>(data|ref|object)</code> (list of XML names)</li>
							<li><code>ID</code> for identifying elements (part of <code><link href="ididref"/></code>)</li>
							<li><code>IDREF</code> for referencing identified elements (part of <code><link href="ididref"/></code>)</li>
						</ul>
						<li>Application-oriented attribute types are often <q>simulated</q></li>
						<ul>
							<li>using <link href="param-entity"/>, modeling information can be preserved</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="894-894"/>
					<listing src="xhtml1-transitional.dtd" line="52-53"/>
					<ul>
						<li>The default declaration specifies the attribute's presence</li>
						<ul>
							<li><code>#REQUIRED</code> means the attribute has to be specified (on every element)</li>
							<li><code>#IMPLIED</code> marks an optional attribute (the parser may imply a value)</li>
							<li><code>"…"</code> specifies a default value (and the attribute is optional)</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Advanced DTDs</title>
			<part id="ididref">
				<title>ID/IDREF</title>
				<slide>
					<title>References in Documents</title>
					<ul>
						<li>Without Validation, there are no IDs</li>
						<ul>
							<li><code>ID</code> is an <link href="dtd-attr-type">attribute type</link> declared in the DTD</li>
							<li><link href="xml:id"><code>xml:id</code></link> is an attempt to support schema-independent IDs</li>
						</ul>
						<li>IDs are used to assign identities to elements</li>
						<ul>
							<li>the XML processor reports duplicate IDs as errors (<a href="http://www.w3.org/TR/xml/#id">part of validation</a>)</li>
						</ul>
						<li>IDREFs are used to reference existing IDs</li>
						<ul>
							<li>the XML processor reports references to non-existing IDs as errors (<a href="http://www.w3.org/TR/xml/#idref">part of validation</a>)</li>
						</ul>
						<li>IDs must be XML Names (in particular, they may not start with a number)</li>
					</ul>
				</slide>
				<slide>
					<title>ID/IDREF in a Document</title>
					<listing src="section.xml" line="3-18"/>
					<listing src="section.dtd" line="2-12"/>
				</slide>
				<slide>
					<title>References within the Tree</title>
					<img src="section.png" style="width : 90% ; margin : 4% ; "/>
				</slide>
				<slide>
					<title>Formatting Example</title>
					<p>Hotspot can generate links to sections such as the section about <link href="ididref"/>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>
					<pre><![CDATA[<p>Hotspot can generate links to sections such as the section about <link href="ididref"/>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>]]></pre>
					<p>After running Hotspot, the following HTML is generated:</p>
					<pre><![CDATA[<p>Hotspot can generate links to sections such as the section about <a href="#ididref">ID/IDREF</a>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>]]></pre>
				</slide>
				<slide>
					<title>ID/IDREF Semantics</title>
					<ul>
						<li>Rooted in the document world</li>
						<ul>
							<li>all parts are assembled before processing</li>
							<li>names are symbolic and assigned as required</li>
							<li>mixed syntax and semantics</li>
						</ul>
						<li>Good idea, but many shortcomings</li>
						<ul>
							<li>constraints apply to one document only</li>
							<li>IDs and IDREFs are global instead of scoped</li>
							<li>identifiers should be allowed to use any type</li>
							<li>identifier processing should be type-specific (2 &#x225F; 02)</li>
						</ul>
						<li>Applications must know how to process ID/IDREF</li>
						<ul>
							<li>for HTML export, links can be generated</li>
							<li>for databases, keys should be used</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="dtd-entity">
				<title>Entities</title>
				<slide>
					<title>General Entities</title>
					<ul>
						<li>XML's core concept of physical data structures</li>
						<ul>
							<li>an entity is a named unit of data which can be referenced</li>
							<li>within documents, it is referenced by the markup <code>&amp;entity-name;</code></li>
						</ul>
						<li>Entities can be used to name and reuse document content</li>
					</ul>
					<listing src="xhtml-lat1.ent" line="135-142"/>
					<ul>
						<li><em>Character References</em> look like entities: <code>&amp;#9786;</code> or <code>&amp;#x263A;</code> = &#x263A;</li>
						<ul>
							<li>they can be used to represent any Unicode character, they are processed as single characters</li>
						</ul>
					</ul>
				</slide>
				<slide id="param-entity">
					<title>Parameter Entities</title>
					<ul>
						<li>Parameter entities are parsed entities for use within the DTD</li>
						<ul>
							<li>a parameter entity must be specifically declared as such</li>
							<li>within DTDs, it is referenced by the markup <code>%entity-name;</code></li>
							<li>outside of DTDs, parameter entities cannot be used</li>
						</ul>
						<li>As general entities, parameter entities are meant for reuse</li>
						<ul>
							<li>in a DTD, reuse is mostly about reusing structures</li>
							<li>parameter entities are DTDs <q>duct tape</q>, not elegant, but effective</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XHTML Parameter Entities (Attributes)</title>
					<listing src="xhtml1-transitional.dtd" line="433-437"/>
					<listing src="xhtml1-transitional.dtd" line="188-188"/>
					<listing src="xhtml1-transitional.dtd" line="133-138"/>
					<listing src="xhtml1-transitional.dtd" line="145-149"/>
					<listing src="xhtml1-transitional.dtd" line="55-56"/>
					<listing src="xhtml1-transitional.dtd" line="193-193"/>
				</slide>
				<slide>
					<title>XHTML Parameter Entities (Content)</title>
					<listing src="xhtml1-transitional.dtd" line="433-437"/>
					<listing src="xhtml1-transitional.dtd" line="230-230"/>
					<listing src="xhtml1-transitional.dtd" line="227-227"/>
					<listing src="xhtml1-transitional.dtd" line="203-204"/>
					<listing src="xhtml1-transitional.dtd" line="200-201"/>
					<listing src="xhtml1-transitional.dtd" line="197-198"/>
					<listing src="xhtml1-transitional.dtd" line="222-222"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>DTD for XML Schemas</title>
				<ul>
					<li>XML documents are processed by applications</li>
					<li>Applications have assumptions about XML documents</li>
					<li>DTDs allow to formalize some of these constraints</li>
					<li>Part of the constraint checking must still be programmed</li>
				</ul>
			</slide>
			<slide>
				<title>Modeling DTDs</title>
				<ul>
					<li>Data models can be mapped to many different DTDs</li>
					<li>What is a good DTD? What is a bad DTD?</li>
					<li>How does the DTD affect further processing?</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xpath">
		<title short="XPath">XML Path Language (XPath)</title>
		<date>2013-09-16</date>
		<toc class="assignment"><a href="a/3/">A3</a>&#160;assigned (due&#160;date:&#160;10/1)</toc>
		<toc class="resources"><a href="http://www.w3.org/TR/xpath" title="W3C XPath 1.0 Specification">XPath&#160;1.0&#160;Spec</a>&#160;· <a href="xpath-chapter.pdf">XPath Chapter</a></toc>
		<toc class="abstract">XML structures data into a rather small number of different constructs, most notably elements and attributes. The <em>XML Path Language (XPath)</em> defines a way how to select parts of XML documents, so that they can be used for further processing. XPath's primary use in in <em>XSL Transformations (XSLT)</em>, but other XML technologies use it as well, e.g. XSD. XPath is a very compact language with a syntax that resembles path expressions well-known from file systems. These path expressions, however, are generalized and therefore much more powerful than the rather simple path expressions in file systems. Because of its use in different XML technologies, XPath is one of the most important XML core technologies.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Why XPath?</title>
			<slide>
				<title>Selecting Parts of XML Documents</title>
				<ul>
					<li>XML is a syntax for trees</li>
					<ul>
						<li>it defines a way for how trees can be exchanged</li>
					</ul>
					<li>XML technologies should provide support for working with trees</li>
					<ul>
						<li>when receiving trees, access to the tree should be easy (DOM)</li>
						<li>validating trees should be easy (<link href="xsd-1">XSD</link>)</li>
						<li>mapping trees should be easy (<link href="xslt-1">XSLT</link>)</li>
						<li>querying tree collections should be easy (<link href="xquery">XQuery</link>)</li>
						<li>XPath is what regular expressions for text-based information</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Making Selection Reusable</title>
				<ul>
					<li>Different XML technologies need selection</li>
					<ul>
						<li><link href="xslt-1">XSLT</link> needs it for selecting parts and manipulating them</li>
						<li><link href="xsd-1">XSD</link> needs it for applying identity constraints</li>
						<li>DOM needs it for extracting parts from an XML tree</li>
						<li>XQuery needs it for writing XML-oriented queries</li>
					</ul>
					<li>XPath was created to be reusable</li>
					<ul>
						<li>XML experts should only learn one selection language</li>
						<li>this knowledge can be reused when learning new technologies</li>
						<li>implementations can reuse code libraries</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>How XPath Evolved</title>
				<ul>
					<li>XSL was designed as the new XML stylesheet language</li>
					<ol>
						<li><link href="xslt-1">XSL Transformations (XSLT)</link> transform the input document</li>
						<li><em>XSL Formatting Objects (XSL-FO)</em> is what they will transform it to</li>
					</ol>
					<li>XSLT was designed to work on arbitrary XML input documents</li>
					<ul>
						<li>started as a part of XSL (<a href="http://www.w3.org/TR/1998/WD-xsl-19981216">WD-xsl-19981216</a> → <a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a>)</li>
						<li>for selecting parts of the transformation input, a selection mechanism had to be provided</li>
					</ul>
					<li>XPath was turned into a standalone specification</li>
					<ul>
						<li>started as a part of XSLT (<a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a> → <a href="http://www.w3.org/1999/07/WD-xslt-19990709">WD-xslt-19990709</a>)</li>
						<li>reused in a number of other W3C specifications (XSD, DOM)</li>
					<li>Complete overhaul for XSLT 2.0 and XQuery</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xpath20/">XPath 2.0</a> as the core language</li>
						<li>a much larger set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
						<li>the underlying <a href="http://www.w3.org/TR/xpath-datamodel/">data model</a> which describes the foundation</li>
					</ul>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>How XPath Works</title>
			<part id="xpath-tree">
				<title>The XPath Tree Model</title>
				<slide>
					<title>Starting from the Infoset</title>
					<ul>
						<li>XPath operates on an abstract data model</li>
						<ul>
							<li>a tree derived from the <link href="infoset"/></li>
							<li>a simplification (another one!) of the underlying XML</li>
						</ul>
						<li>The Infoset is turned into an <em>XPath node tree</em></li>
						<ul>
							<li>11 infoset item types → 7 XPath node tree node types</li>
							<li>character items are merged into text nodes</li>
							<li>namespace declarations are no longer visible as attributes</li>
						</ul>
					</ul>
				</slide>
				<slide id="not-xpath">
					<title>What is <u>Not</u> in the XPath Tree</title>
					<ul>
						<li>The same things which are <link href="not-infoset">not in the Infoset</link></li>
						<ul>
							<li>the order of attributes in a start tag</li>
							<li>the types of quotes around attribute values</li>
							<li>character references and entities (<code>&amp;#xFC;</code>/<code>&amp;uuml;</code> → <code>ü</code>)</li>
						</ul>
						<li>And some more …</li>
						<ul>
							<li>namespace declarations are no longer visible as attributes</li>
							<li>notations and unexpanded entity references</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part>
				<title>XPath Evaluation</title>
				<slide>
					<title>Tree In / Selection Out</title>
					<ul>
						<li>XPath evaluates an expression based on a tree</li>
						<li>Where the tree comes from is out of XPath's scope</li>
						<li>The result of the evaluation is a selection</li>
						<ul>
							<li><code>//img[not(@alt)]</code> → select all images which have no <code>alt</code> attribute</li>
							<li><code>count(//img)</code> → return the number of images</li>
							<li><code>/descendant::img[3]/@src</code> → return the third image's <code>src</code> URI</li>
							<li><code>starts-with(/html/@lang, 'en')</code> → test whether the document's language is english</li>
						</ul>
						<li>Syntax errors may occur</li>
						</ul>
				</slide>
			</part>
		</part>
		<part>
			<title short="Location Paths">XPath Location Paths</title>
			<slide>
				<title>Location Path Structure</title>
				<ul>
					<li>Each location path consists of <em>Location Steps</em></li>
					<ul>
						<li>location steps are separated by <q><code>/</code></q>, like path names in file systems</li>
					</ul>
					<li>Similarities between XPath location paths and file systems</li>
					<ol>
						<li>nodes in the <link href="xpath-tree">XPath tree</link> have different types</li>
						<li>the <link href="xpath-nodetest">type and number of nodes selected by one step</link></li>
						<li>the <link href="xpath-axes">direction in which each step moves</link></li>
						<li>additional <link href="xpath-predicates">filters for selecting specific nodes</link></li>
					</ol>
					<li>Differences between XPath location paths and file systems</li>
					<ol>
						<li>XPaths may return <link href="xpath-expressions">other data types than nodes</link></li>
						<li>XPath provides a <link href="xpath-functions">built-in function library</link></li>
					</ol>
				</ul>
			</slide>
			<part>
				<title short="Node Tests">XPath Node Tests</title>
				<slide>
					<title>File System vs. XPath Paths</title>
					<table style="margin : 5% ; " width="85%">
						<tr>
							<th>File System Path:</th>
							<td align="center"><code>/</code></td>
							<td align="center"><code>usr</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>local</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>apache</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>bin</code></td>
							<td align="center"><code>/</code></td>
						</tr>
						<tr>
							<th># Selected Nodes:</th>
							<td align="center">1</td>
							<td align="center">→ 1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">1</td>
						</tr>
					</table>
					<table style="margin : 5% ; " width="85%">
						<tr>
							<th>XPath:</th>
							<td align="center"><code>/</code></td>
							<td align="center"><code>html</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>body</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>table</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>thead</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>tr</code></td>
						</tr>
						<tr>
							<th># Selected Nodes:</th>
							<td align="center">1</td>
							<td align="center">→ 1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">6</td>
							<td align="center">→</td>
							<td align="center">4</td>
							<td align="center">→</td>
							<td align="center">12</td>
						</tr>
					</table>
				</slide>
				<slide id="xpath-nodetest">
					<title>Tests for Nodes</title>
					<ul>
						<li>Name tests</li>
						<ul>
							<li>testing for a particular name (elements/attributes): <code>/html/head/title</code></li>
							<li>wildcards (testing for any name): <code>/html/head/*</code></li>
						</ul>
						<li>Node type tests</li>
						<ul>
							<li>text nodes: <code>text()</code></li>
							<li>comment nodes: <code>comment()</code></li>
							<li>any nodes: <code>node()</code></li>
						</ul>
						<li>Processing instruction tests</li>
						<ul>
							<li>any PI: <code>processing-instruction()</code></li>
							<li>specific PI: <code>processing-instruction("xml-stylesheet")</code></li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xpath-axes">
				<title short="Axes">XPath Axes</title>
				<slide>
					<title>Where Do You Want to Go Today?</title>
					<ul>
						<li>File system paths are one direction only</li>
						<ul>
							<li>always one level down in the file system hierarchy</li>
							<li><code>.</code> and <code>..</code> are clever directory shortcuts</li>
							<li>other directions supported by tools (e.g., <code>find</code>)</li>
						</ul>
						<li>XPath allows steps is different directions</li>
						<ul>
							<li>the default direction is <code>child</code></li>
							<li>other directions are explicitly specified: <code>descendant::a</code></li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Axis Peculiarities</title>
					<ul>
						<li>Attributes and Namespaces are <u>not</u> the children of elements, but …</li>
						<li>… elements are their attributes' parent!</li>
						<ul>
							<li>very counter-intuitive</li>
							<li>very convenient</li>
						</ul>
						<li>Attributes and Namespaces are always leaves in the node tree</li>
						<li>Attribute nodes <u>have</u> the attribute value as their value</li>
						<li>Namespace nodes <u>have</u> the namespace name (i.e., a URI) as their value</li>
						<li>Namespace nodes exist because of namespace declarations</li>
						<ul>
							<li>in the XPath node tree, only the namespace nodes are visible</li>
							<li>the namespace declaration attributes (<code>xmlns</code>) are invisible</li>
							<li>one namespace declaration potentially creates many namespace nodes</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Axes</title>
					<img style="height : 75% ; margin : 2% ; " src="xpath-axes.png" title="XPath Axes"/>
				</slide>
				<slide>
					<title>Putting it all Together</title>
					<ul>
						<li>XPath location paths use a simple syntax</li>
						<ul>
							<li>sequence of location steps, separated by <q><code>/</code></q></li>
						</ul>
						<li>Each location step uses a simple structure (<code>preceding::p[@class="warning"]</code>)</li>
						<ol>
							<li>an axis followed by <q><code>::</code></q> (no axis uses the default axis <code>child</code>)</li>
							<li>a <link href="xpath-nodetest">node test</link></li>
							<li><em>0-n</em> <link href="xpath-predicates"/> enclosed in <q><code>[]</code></q></li>
						</ol>
						<li>Location paths can be abbreviated</li>
						<ul>
							<li><code>child::</code> can be omitted (default axis)</li>
							<li><code>attribute::</code> can be written as <q><code>@</code></q></li>
							<li><q><code>.</code></q> is an abbreviation for <code>self::node()</code></li>
							<li><q><code>..</code></q> is an abbreviation for <code>parent::node()</code></li>
							<li><q><code>//</code></q> is an abbreviation for <code>/descendant-or-self::node()/</code></li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xpath-predicates">
				<title>Predicates</title>
				<slide>
					<title>Location Step Filters</title>
					<ul>
						<li>Predicates are filters for each location step</li>
						<ul>
							<li>there can be any number of filters (<em>0-n</em>)</li>
							<li>each filter is applied to each selected node individually</li>
						</ul>
						<li>Each predicate is an XPath and evaluated as a boolean</li>					
						<ul>
							<li>the context of this evaluation is the node for which the filter is evaluated</li>
							<li>if the result is a number, it is compared with the <code>position()</code> function (<code>/descendant::a[5]</code>)</li>
						</ul>
						<li>Predicates always reduce the set of selected nodes</li>
						<ul>
							<li>as corner cases, the set of selected nodes does not change or is empty</li>
							<li>predicates are used in the majority of non-trivial XPath location paths</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Location Path Processing</title>
					<ul>
						<li>Location paths are processed in a very simple way</li>
						<ol>
							<li>start with a given context</li>
							<li>for each location step, repeat the following steps:</li>
							<li>based on the context and the axis, select the nodes on this axis</li>
							<li>reduce this selection to the nodes identified by the node test</li>
							<li>sequentially apply all filters to each of these nodes</li>
							<li>take the remaining node set as the context for the next location step</li>
						</ol>
					</ul>
				</slide>
			</part>
		</part>
		<part id="xpath-expressions">
			<title>XPath Expressions</title>
			<slide>
				<title>Beyond Location Paths</title>
				<ul>
					<li>XPath is a full expression language</li>
					<ul>
						<li>any evaluated expression in XSLT is an XPath</li>
						<li>XPath must be able to calculate operate on non-XML data types</li>
					</ul>
					<li>XPath uses a very simple data model</li>
					<ol>
						<li>node sets: <code>//img[not(@alt)]</code></li>
						<li>number: <code>count(//img)</code></li>
						<li>string: <code>/descendant::img[3]/@src</code></li>
						<li>boolean: <code>starts-with(/html/@lang, 'en')</code></li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>XPath Usages</title>
				<ul>
					<li>XPath is used in different technologies</li>
					<ul>
						<li>XSLT uses XPath as its expression language</li>
						<li>XSD uses XPath for selecting identity constraint nodes</li>
						<li>DOM uses XPath as a way to select DOM nodes</li>
					</ul>
					<li>Depending on the environment, expression must yield certain results</li>
					<ul>
						<li>for conditionals, a boolean must be returned</li>
						<li>iterations (in XSLT) only loop over nodes</li>
						<li>when printing out text, a string must be produced</li>
					</ul>
					<li>XPath has built-in rules for casting types</li>
					<ul>
						<li>node set → boolean: empty is false, non-empty is true</li>
						<li>node → string: take the <em>string value</em> (i.e., concatenate all text node descendants)</li>
						<li>string → number: interpret as decimal notation (otherwise return <q><code>NaN</code></q>)</li>
						<li>XPaths often return surprising results (<code>//a[starts-with(@href, https)]</code>)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="xpath-functions">
			<title>XPath Functions</title>
			<slide>
				<title>Function Library</title>
				<ul>
					<li>XPath has a small library of built-in functions</li>
					<ul>
						<li>useful for basic XPath-level functions</li>
						<li>other specs are allowed to extend it (XSLT does it)</li>
					</ul>
					<li>XPath functions return results of various data types</li>
					<ul>
						<li>boolean: <code>boolean, contains, false, lang, not, starts-with, true</code></li>
						<li>number: <code>ceiling, count, floor, last, number, position, round, string-length, sum</code></li>
						<li>string: <code>concat, local-name, name, namespace-uri, normalize-space, string, substring, substring-after, substring-before, translate</code></li>
						<li>node set: <code>id</code></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Using Functions</title>
				<ul>
					<li>Functions and location paths are orthogonal</li>
					<ul>
						<li>each construct may be based on the other</li>
						<li>it is possible to nest them arbitrarily</li>
						<li>predicates often contain functions</li>
						<pre>//a[substring(@href,string-length(@href)-2)='pdf']</pre>
					</ul>
					<li>XPaths can become powerful and complex</li>
					<ul>
						<li>writing some code or thinking about an XPath?</li>
						<li>XPaths are more declarative</li>
						<li>they may be more robust against changes in the XML schema</li>
						<li>they can be optimized by a smart XPath implementation</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Limitations of XPath</title>
			<slide>
				<title>XPath Selects</title>
				<ul>
					<li>Query languages select and recombine</li>
					<ol>
						<li>look up all addresses by zip code</li>
						<li>for each zip code, count the number of addresses</li>
					</ol>
					<li>XSLT fills in the missing parts (as a programming language)</li>
					<ul>
						<li>XSLT can construct XML and re-apply XPath</li>
					</ul>
					<li>XQuery fills in the missing parts (query-wise)</li>
					<ul>
						<li>80% of XQuery are XPath (in version 2.0, though)</li>
						<li>the remaining 20% are bindings, constructors, and glue</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XPath is Important</title>
				<ul>
					<li>XPath is a basic tool of the XML toolbox</li>
					<li>XPath is reused in various XML technologies</li>
					<li>XPath selects parts of an XML document</li>
					<li>XPath can do more general things by using expressions</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xpath20">
		<title short="XPath 2.0">XML Path Language (XPath) 2.0</title>
		<date>2013-09-18</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xpath20" title="W3C XPath 2.0 Specification">XPath&#160;2.0&#160;Spec</a></toc>
		<toc class="abstract">The <em>XML Path Language (XPath)</em> is one of the most useful and frequently used languages in the area of XML technologies. In its version 1.0, it is used in technologies such as XSLT, XSD, DOM, and XML Tools. With <em>XPath 2.0</em>, the language has been greatly extended, the new version of XPath is the foundation for XSLT 2.0 and XQuery. XPath 2.0 provides support for regular expression matching, typed expressions, and contains language constructs for conditional and repeated evaluation.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Why XPath?</title>
			<slide>
				<title>Selecting Parts of XML Documents</title>
				<ul>
					<li>XML is a syntax for trees</li>
					<ul>
						<li>it defines a way for how trees can be exchanged</li>
					</ul>
					<li>XML technologies should provide support for working with trees</li>
					<ul>
						<li>when receiving trees, access to the tree should be easy (DOM)</li>
						<li>validating trees should be easy (<link href="xsd-1">XSD</link>)</li>
						<li>mapping trees should be easy (<link href="xslt-1">XSLT</link>)</li>
						<li>querying tree collections should be easy (<link href="xquery">XQuery</link>)</li>
						<li>XPath is what regular expressions for text-based information</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Making Selection Reusable</title>
				<ul>
					<li>Different XML technologies need selection</li>
					<ul>
						<li><link href="xslt-1">XSLT</link> needs it for selecting parts and manipulating them</li>
						<li><link href="xsd-1">XSD</link> needs it for applying identity constraints</li>
						<li>DOM needs it for extracting parts from an XML tree</li>
						<li>XQuery needs it for writing XML-oriented queries</li>
					</ul>
					<li>XPath was created to be reusable</li>
					<ul>
						<li>XML experts should only learn one selection language</li>
						<li>this knowledge can be reused when learning new technologies</li>
						<li>implementations can reuse code libraries</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>How XPath Evolved</title>
				<ul>
					<li>XSL was designed as the new XML stylesheet language</li>
					<ol>
						<li><em>XSL Transformations (XSLT)</em> transform the input document</li>
						<li><em>XSL Formatting Objects (XSL-FO)</em> is what they will transform it to</li>
					</ol>
					<li>XSLT was designed to work on arbitrary XML input documents</li>
					<ul>
						<li>started as a part of XSL (<a href="http://www.w3.org/TR/1998/WD-xsl-19981216">WD-xsl-19981216</a> → <a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a>)</li>
						<li>for selecting parts of the transformation input, a selection mechanism had to be provided</li>
					</ul>
					<li>XPath was turned into a standalone specification</li>
					<ul>
						<li>started as a part of XSLT (<a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a> → <a href="http://www.w3.org/1999/07/WD-xslt-19990709">WD-xslt-19990709</a>)</li>
						<li>reused in a number of other W3C specifications (XSD, DOM)</li>
					</ul>
					<li>Complete overhaul for XSLT 2.0 and XQuery</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xpath20/">XPath 2.0</a> as the core language</li>
						<li>a much larger set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
						<li>the underlying <a href="http://www.w3.org/TR/xpath-datamodel/">data model</a> which describes the foundation</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>How XPath Works</title>
			<part>
				<title>The XPath Tree Model</title>
				<slide>
					<title>Starting from the Infoset</title>
					<ul>
						<li>XPath operates on an <link href="xpath-tree">abstract data model</link></li>
						<ul>
							<li>a tree derived from the <link href="infoset"/></li>
							<li>a simplification (another one!) of the underlying XML</li>
						</ul>
						<li>The Infoset is turned into an <em>XPath node tree</em></li>
						<ul>
							<li>11 infoset item types → 7 XPath node tree node types</li>
							<li>character items are merged into text nodes</li>
							<li>namespace declarations are no longer visible as attributes</li>
						</ul>
					</ul>
				</slide>
				<slide id="not-xpath">
					<title>What is <u>Not</u> in the XPath Tree</title>
					<ul>
						<li>The same things which are <link href="not-infoset">not in the Infoset</link></li>
						<ul>
							<li>the order of attributes in a start tag</li>
							<li>the types of quotes around attribute values</li>
							<li>character references and entities (<code>&amp;#xFC;</code>/<code>&amp;uuml;</code> → <code>ü</code>)</li>
						</ul>
						<li>And some more …</li>
						<ul>
							<li>namespace declarations are no longer visible as attributes</li>
							<li>notations and unexpanded entity references</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part>
				<title>XPath Evaluation</title>
				<slide>
					<title>Tree In / Selection Out</title>
					<ul>
						<li>XPath evaluates an expression based on a tree</li>
						<li>Where the tree comes from is out of XPath's scope</li>
						<li>The result of the evaluation is a selection</li>
						<ul>
							<li><code>//img[not(@alt)]</code> → select all images which have no <code>alt</code> attribute</li>
							<li><code>count(//img)</code> → return the number of images</li>
							<li><code>/descendant::img[3]/@src</code> → return the third image's <code>src</code> URI</li>
							<li><code>starts-with(/html/@lang, 'en')</code> → test whether the document's language is english</li>
						</ul>
						<li>Syntax errors may occur</li>
						</ul>
				</slide>
			</part>
		</part>
		<part>
			<title short="XPath 1.0">XPath 1.0 Revisited</title>
			<slide>
				<title>Source Document</title>
				<listing src="xlinked-class.xml" line="81-98" title="Web-Based Publishing Class – Spring 2007"/>
			</slide>
			<slide>
				<title>XPath Expressions</title>
				<ul>
					<li>XPaths can be location paths</li>
					<pre>//ul/li</pre>
					<li>XPaths can use functions</li>
					<pre>id('dret')</pre>
					<li>XPaths can be expressions yielding atomic values</li>
					<pre>substring-before(id('dret'), ' ')</pre>
					<li>XPaths can combine all of the above</li>
					<pre>count(//ul/li[starts-with(substring-after(., ' '), 'W')])</pre>
				</ul>
			</slide>
			<slide>
				<title>Axes</title>
				<img style="width : 86% ; margin : 4% ; " src="xpath-axes.png"/>
			</slide>
		</part>
		<part>
			<title>Ease of Use</title>
			<slide>
				<title>Easier to Understand</title>
				<ul>
					<li>XPath 2.0 provides better ways to write XPaths</li>
					<ul>
						<li>some constructs allow better ways of writing XPaths</li>
						<li>some constructs allow things previously impossible in XPath</li>
					</ul>
					<li>XPath usually is embedded in another language (XQuery, XSLT)</li>
					<ul>
						<li>even in XSLT 1.0, there was always a trade-off between XPath and XSLT</li>
						<li>with XPath 2.0, even more powerful XPaths can be implemented</li>
					</ul>
					<li>Finding a good balance between XPath and the host language is an art</li>
					<ul>
						<li>very complex XPaths can become almost undecipherable</li>
						<li>there is no final answer, coding styles vary based on language preference</li>
					</ul>
				</ul>
				<pre>&lt;listing src="xlinked-class.xml" line="81-98"/></pre>
				<pre>string-join(tokenize( if ( exists(@encoding) ) then unparsed-text($fileuri, @encoding) else unparsed-text($fileuri), '\r?\n')[(position() ge number(tokenize(current()/@line, '\-')[1])) and (position() le number(tokenize(current()/@line, '\-')[2]))], '&amp;#xa;')</pre>
			</slide>
			<part id="xpath20-conditional">
				<title>Conditional Expressions</title>
				<slide>
					<title>Control Flow in XPath</title>
					<ul>
						<li>XPath 1.0 expressions <q>control flow</q> is based on predicates</li>
						<ul>
							<li>the results of location path steps are filtered by predicates</li>
							<li>this can be used to <q>emulate</q> control flow</li>
							<li>this technique is limited because it can only be applied to nodes</li>
						</ul>
						<li>XPath 2.0 introduces conditional expressions</li>
						<ul>
							<li>a condition is given which is interpreted as a boolean</li>
							<li>based on the result, either the <xpath>then</xpath> or the <xpath>else</xpath> part is evaluated</li>
							<li>the else part may not be omitted</li>
						</ul>
					</ul>
					<pre>if ( … ) then … else …</pre>
					<pre>if ( @sex eq 'm' ) then 'Sir' else 'Madam'</pre>
					<pre>if ( @sex eq 'm' ) then 'Sir' else if ( @sex eq 'f' ) then 'Madam' else 'Whatever'</pre>
				</slide>
				<slide>
					<title>Less XSLT</title>
					<listing src="names.xml"/>
					<pre>first | last[not(../first)]</pre>
					<pre><![CDATA[<xsl:variable name="name">
	<xsl:choose>
		<xsl:when test="first">
			<xsl:value-of select="first"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="last"/>
		</xsl:otherwise>
	</xsl:choose>
</xsl:variable>]]></pre>
					<pre>if ( exists(first) ) then first else last</pre>
				</slide>
			</part>
			<part id="xpath20-iterations">
				<title>Iterations</title>
				<slide>
					<title>Repeating Expression Evaluation</title>
					<ul>
						<li>Iteration repeatedly applies an expression to a sequence of items</li>
						<ul>
							<li>the notion of <link href="xpath20-sequences"/> is central to this concept</li>
							<li>this requires variables for binding and evaluation</li>
						</ul>
						<li>Iterations clearly demonstrate the change in expressiveness</li>
						<ul>
							<li>they introduce functionality which previously was limited to host languages</li>
						</ul>
					</ul>
					<pre>for $… in … return …</pre>
					<pre>for $i in //name return $i/last</pre>
					<pre>for $i in //name return if ( exists($i/first) ) then $i/first else $i/last</pre>
				</slide>
				<slide>
					<title>Iterations vs. Location Paths</title>
					<ul>
						<li>Every location path can be written using iterations</li>
						<pre>/names/name/last</pre>
						<pre>for $i in /names return for $j in $i/name return $j/last</pre>
						<li>Iterations are a more generalized way of evaluation</li>
						<ul>
							<li>path expressions work on nodes only</li>
							<pre>for $i in 1 to 10 return $i</pre>
							<li>path expression sort by document order and eliminate duplicates</li>
							<pre>//last/../..</pre>
							<pre>for $i in //last return for $j in $i/.. return $j/..</pre>
							<li>location steps change the context, iterations use the variable for this purpose</li>
						</ul>
						<li>Location paths are a useful syntax and method for tree navigation</li>
					</ul>
				</slide>
			</part>
			<part id="xpath20-quantified">
				<title>Quantified Expressions</title>
				<slide>
					<title>Testing Sequences</title>
					<ul>
						<li>Testing whether some or all items of a sequence satisfy a condition</li>
						<ul>
							<li>the notion of <link href="xpath20-sequences"/> is central to this concept</li>
							<li>this requires variables for binding and evaluation</li>
						</ul>
						<li>Quantifiers are well-known from query languages</li>
						<ul>
							<li><xpath>some</xpath> iterates over items and succeeds after the first success</li>
							<li><xpath>every</xpath> iterates over items and fails after the first failure</li>
							<li>both constructs are good candidates for optimization</li>
						</ul>
					</ul>
					<pre>( some | every ) $… in … satisfies …</pre>
					<pre>some $i in //*[@xlink:type='locator']/@xlink:href satisfies $i eq $query-uri</pre>
					<pre>every $i in //li/@id satisfies //*[@xlink:type='locator'][@xlink:href=concat('#', $i)]</pre>
				</slide>
			</part>
		</part>
		<part id="xpath20-sequences">
			<title>Sequences</title>
			<slide>
				<title>Major Changes</title>
				<ul>
					<li>XPath 1.0 has a very simple data model</li>
					<ol>
						<li>node sets: <code>//img[not(@alt)]</code></li>
						<li>number: <code>count(//img)</code></li>
						<li>string: <code>/descendant::img[3]/@src</code></li>
						<li>boolean: <code>starts-with(/html/@lang, 'en')</code></li>
					</ol>
					<li>XPath 2.0 needs a more powerful model for its advanced functionality</li>
					<ul>
						<li>everything in XPath 2.0 is a sequence</li>
						<li>sequences can contain a mix of items of various types</li>
						<li>sequences cannot be nested (there are no sequences of sequences)</li>
					</ul>
				</ul>
				<pre>every $i in ( 11, 22, 33, 'string' ) satisfies string(number($i)) ne 'NaN'</pre>
			</slide>
			<slide>
				<title>Divide and Conquer</title>
				<ul>
					<li>Sequences are part of the <a href="http://dret.net/lectures/xml-fall08/xdm">XDM</a></li>
					<ul>
						<li>data models are separate entities from evaluation languages</li>
						<li>a data model can be reused in different evaluation languages</li>
					</ul>
					<li>XDM is far more complex than its predecessor, the Infoset</li>
					<ul>
						<li>XSD datatypes have been integrated into the data model</li>
						<li>Sequences allow more complex structures to exist</li>
					</ul>
					<li>Understanding the data model is key to understanding the language</li>
					<ul>
						<li>for simple XPaths, the mental model of XPath 1.0 works</li>
						<li>more advanced XPaths can only be understood when understanding XDM</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Applications</title>
			<slide>
				<title>Standalone</title>
				<ul>
					<li>XPath can be used in standalone XML tools</li>
					<ul>
						<li>editors provide XPath evaluation as <q>regular expressions for XML</q></li>
						<li>text-based searches in bigger XML documents are not a good idea</li>
					</ul>
					<li>Standalone tools are good for learning XPaths</li>
					<ul>
						<li>many tools support interactive evaluation</li>
						<li>seeing sequences visualized often is very helpful</li>
					</ul>
				</ul>
				<pre>for $i in ( 11, 22, 33, 'string' ) return ($i, number($i))</pre>
			</slide>
			<slide>
				<title>XQuery</title>
				<ul>
					<li><link href="xquery">XQuery</link> is built on top of XPath 2.0</li>
					<ul>
						<li>XPath allows constructing sequences based on documents</li>
						<li>XPath has no way of generating new document structures</li>
					</ul>
					<li>XQuery builds a query language around XPath</li>
					<ul>
						<li>the basic idea is to provide a language for constructing results from sequences</li>
						<li>~80% of the complexity of XQuery are in XPath 2.0</li>
					</ul>
				</ul>
				<pre ahref="http://www.stylusstudio.com/xquery_primer.html"><![CDATA[declare variable $firstName external;
<videos featuring="{$firstName}"> {
  let $doc := .
  for $v in $doc//video, $a in $doc//actors/actor
  where ends-with($a, $firstName) and $v/actorRef = $a/@id
  order by $v/year
  return
	<video year="{$v/year}"> { $v/title } </video> }
</videos>]]></pre>
			</slide>
			<slide>
				<title>XSLT 2.0</title>
				<ul>
					<li>XSLT 2.0 is based on <link href="xslt-1">XSLT 1.0</link> and built on top of XPath 2.0</li>
					<ul>
						<li>XPath allows constructing sequences based on documents</li>
						<li>XPath has no way of generating new document structures</li>
					</ul>
					<li>XSLT focuses on transformations rather than queries</li>
					<ul>
						<li><q>a query is a transformation is a query</q></li>
						<li>language preference is more a question of training and experience</li>
					</ul>
					<li>Many problems can be appropriately solved with both languages</li>
					<ul>
						<li>XQuery is favored by database people and by the big vendors</li>
						<li>XSLT 2.0 is favored by XML people who worked a lot with XSLT 1.0</li>
						<li>implementations could easily support both languages</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Easy Transition</title>
				<ul>
					<li>XPath 1.0 users can start using XPath 2.0 right away</li>
					<li>apart from a <a href="http://www.w3.org/TR/xpath20/#id-backwards-compatibility" title="XPath 2.0 Spec: Backwards Compatibility with XPath 1.0">few corner cases</a>, the results will be the same</li>
					<li>XPath 2.0 has a huge set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
					<li>XSD types can be used, values can be cast</li>
					<li>Regular expressions are supported for working with strings</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xmlapp" external="xml-in-application.pdf">
		<title>XML in Application</title>
		<date>2013-09-23</date>
		<toc class="author">Eric Kansa</toc>
		<toc class="resources"><a href="http://opencontext.org/">Open&#160;Context</a></toc>
		<toc class="abstract">Eric Kansa will discuss "open data" and some implementation strategies for realizing the goals of the open data movement. He will be drawing examples from Open Context, a research data sharing system focusing on archaeology. The discussion will explore pragmatic approaches to using XML and other structured data formats for publishing data on the Web to serve different communities with different levels of technical skills and capabilities.</toc>
	</presentation>
	<presentation id="xmlns">
		<title short="Namespaces">XML Namespaces</title>
		<date>2013-09-25</date>
		<toc class="resources"><a href="http://www.rpbourret.com/xml/NamespacesFAQ.htm#p1">XML Namespaces FAQ (Part I)</a>&#160;· <a href="http://www.w3.org/TR/REC-xml-names/" title="W3C XML Namespaces Specification">Spec</a></toc>
		<toc class="abstract">XML is successful because it can be used in many different scenarios, and because it is easy to define a schema (such as a DTD) for new scenarios, producing a tailored XML data model for this scenario. This means that names in XML documents must be interpreted as belonging to a certain schema. As long as a document uses names from only one schema, this can be done rather easily. However, in many scenarios today documents combine names from different schemas, and <em>XML Namespaces</em> provide a mechanism how the names in an XML document can be associated with a namespace.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>How to think about Namespaces</title>
			<slide>
				<title>Namespaces are Simple</title>
				<ul>
					<li>XML Namespaces are often misunderstood</li>
					<ul>
						<li>the biggest problem is to get rid of some assumptions</li>
						<li>XML Namespaces are too simple and thus confusing</li>
					</ul>
					<li>Instincts of Web users</li>
					<ol>
						<li>URIs identify something that can be retrieved by a browser</li>
						<li>URIs identify something that can be displayed by a browser</li>
						<li>if I cannot get it and cannot look at it, what good can it be?</li>
					</ol>
					<li>However, these assumptions are not always true</li>
					<ol>
						<li>URIs identify <em>resources</em> which often, but not always, can be accessed over the Web</li>
						<li>URIs identify <em>resources</em> which often, but not always, have a Web-accessible representation</li>
						<li>sharing URIs means sharing an identity, which can mean sharing semantics (associated with this identity)</li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>Simple Examples</title>
				<listing src="mathml1.xml" line="2-6"/>
				<listing src="mathml2.xml" line="2-6"/>
				<listing src="mathml3.xml" line="2-6"/>
				<listing src="mathml4.xml" line="2-6"/>
			</slide>
			<slide>
				<title>Name Spaces</title>
				<ul>
					<li>Names are one form of identification</li>
					<li>Identification is essential for communications</li>
					<li>Names in XML are not suitable for identification</li>
					<ul>
						<li>they are local to their context (where they are defined)</li>
						<li>if the context is uniquely identified, the names would be, too</li>
					</ul>
					<li>Name Spaces: <em>Put names into spaces</em></li>
					<ul>
						<li>how to identify the space? Web identifiers are URIs!</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>URI Philosophy</title>
				<ul>
					<li><link href="uri"/> uniquely identify resources</li>
					<li>URIs often provide access information</li>
					<ul>
						<li>pretty clear in <code>http://dret.net/lectures/xml-fall10/</code></li>
						<li>less clear in <code>urn:ietf:rfc:2648</code> (<a href="http://tools.ietf.org/html/rfc2648">RFC 2648</a>)</li>
						<li>very (and purposely) unclear in <code>tag:9327493874329</code> (<a href="http://tools.ietf.org/html/rfc4151">RFC 4151</a>)</li>
					</ul>
					<li>URIs often return <em>resource representations</em></li>
					<ul>
						<li>the resource itself is never returned (how to return a <em>lecture</em>?)</li>
						<li>some representation often is useful (HTML, PDF, maybe video/audio)</li>
						<li>the resource exists and is useful without a representation!</li>
						<li><code href="http://maps.google.com/maps?ll=37.87133,-122.258463&amp;om=1">geo:37.87133;-122.258463</code> is not an <q>information resource</q> (but it exists)</li>
					</ul>
					<li>URIs are much more than just addresses of HTML pages</li>
				</ul>
			</slide>
			<slide>
				<title>The Namespace Problem</title>
				<ul>
					<li>People assume that URIs point to Web pages</li>
					<ul>
						<li>a <em>namespace name</em> (a URI) may point to a Web page</li>
						<li>it may also have no Web page associated with it</li>
						<li>it may even use a URI scheme which cannot be retrieved</li>
						<li>but it is always possible to compare URIs (<q>Do I know this namespace?</q>)</li>
					</ul>
					<li>People assume some standardized content format</li>
					<ul>
						<li>friendly namespaces provide HTML portals (<a href="http://www.w3.org/1999/xhtml">XHTML</a> and <a href="http://www.w3.org/1999/XSL/Transform">XSLT</a>)</li>
						<li>some namespaces just give you the schema (<a href="http://www.w3.org/2001/12/soap-envelope">SOAP</a>)</li>
						<li>they all are correct, because no resource representation is required!</li>
						<li>very unfriendly namespaces may return a 404 or even use inaccessible schemes</li>
					</ul>
					<li>Namespaces are used by comparing URIs</li>
					<ul>
						<li>anything else maybe useful, but is not required and unsafe on the Web</li>
						<li>when searching for a namespace definition, use Google (string search)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Using Namespaces</title>
			<slide>
				<title>Declaring Namespaces</title>
				<ul>
					<li>Using a namespace means referencing names from it</li>
					<ul>
						<li>unfortunately, there is no really standard way of writing these names</li>
						<li>however, the <q><a href="http://www.jclark.com/xml/xmlns.htm">Clark notation</a></q> is useful: <code>{http://www.w3.org/1999/xhtml}html</code></li>
						<li>Namespaces are first declared and then used</li>
					</ul>
					<li><xml>xmlns</xml>-prefixed attributes are used for declaring namespaces</li>
					<ul>
						<li>Default namespace: <elem>html xmlns="http://www.w3.org/1999/xhtml"</elem></li>
						<li>Prefix notation: <elem>xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml"</elem></li>
					</ul>
					<li>Namespace declarations are inherited and can be overwritten</li>
					<ul>
						<li>the default namespace can be undeclared</li>
						<li>Namespace declarations can be used in (too) many ways</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Unhealthy Namespace Usages</title>
				<ul>
					<li>Namespaces can be (and are) used in rather strange ways</li>
					<ul>
						<li>these are syntax variations of identical structures</li>
						<li>without a good (i.e., conforming) parser, interpretation is surprisingly hard</li>
						<li>copy/paste can become hard or impossible</li>
					</ul>
					<li>Namespaces can be <a href="http://lists.xml.org/archives/xml-dev/200204/msg00170.html">neurotic, borderline, psychotic, or normal</a></li>
					<li>Each of the insane cases complicates processing</li>
					<li>None of these has any real technical inaccuracies</li>
					<li>XML should be used with humans in mind</li>
				</ul>
			</slide>
			<slide>
				<title>Unhealthy Namespace Usages in Practice</title>
				<listing src="neurotic.xml" line="2-9"/>
				<listing src="borderline.xml" line="2-9"/>
				<listing src="psychotic.xml" line="2-9"/>
			</slide>
			<slide>
				<title>Elements and Attributes</title>
				<ul>
					<li>Namespaces often apply to elements and attributes</li>
					<ul>
						<li>if an element name has no prefix, it has no namespace or the default namespace is used</li>
						<li>if a name has a prefix, the prefix must be bound to a namespace name</li>
						<li>names like this are called <em>Qualified Names (QNames)</em></li>
					</ul>
					<li>Elements and Attributes are treated differently</li>
					<ul>
						<li>the default namespace only applies to unprefixed <em>element names</em></li>
						<li>as a result, unprefixed <em>attribute names</em> are in no namespace</li>
					</ul>
					<li>Applications should process namespaces and not just use local names</li>
					<ul>
						<li>naïve implementations will break when processing unhealthy instances</li>
						<li>implementing namespaces is not very hard (but not trivial either)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Defining Namespaces</title>
			<slide>
				<title>Any URI is Possible</title>
				<ul>
					<li>A namespace name is a URI, that's all!</li>
					<ul>
						<li>it may not be accessible (because of the URI scheme)</li>
						<li>when retrieving it, nothing may be returned</li>
						<li>when retrieving it, something may be returned</li>
					</ul>
					<li>The only important thing is <em>the name</em></li>
					<ul>
						<li>the name is mentioned in the documentation</li>
						<li>if you know the documentation, you known the name</li>
						<li>shared names mean shared knowledge</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Namespace Definitions</title>
				<ul>
					<li>Namespaces can be defined by a DTD (<a href="http://www.w3.org/TR/xhtml1/#strict">XHTML</a>)</li>
					<li>Namespaces can be defined by XSD (<a href="http://www.w3.org/TR/soap12-part1/#tabnsprefixes">SOAP</a>)</li>
					<li>Namespaces can be defined by RELAX NG (<a href="http://www.w3.org/TR/xhtml2/conformance.html#strict">XHTML 2.0</a>)</li>
					<li>Namespaces can be defined by prose (<a href="http://www.w3.org/TR/xslt#xslt-namespace">XSLT</a>)</li>
					<li>If schemas are provided, additional information is required</li>
					<ul>
						<li>it is unlikely that a namespace can be fully described by a schema</li>
						<li>additional constraints and semantics are specified in prose</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Fixed or Extensible?</title>
				<ul>
					<li>Can a namespace change over time?</li>
					<ul>
						<li>may the namespace description become outdated? extended? replaced?</li>
						<li>this should be clearly documented in the namespace description</li>
					</ul>
					<li>The XML XML Namespace was widely believed <a href="http://www.w3.org/XML/1998/namespace">to be defined by XML</a></li>
					<ul>
						<li><xml>xml:lang</xml> and <xml>xml:space</xml> defined by XML</li>
						<li>but then <xml>xml:base</xml> was added by <em href="http://www.w3.org/TR/xmlbase/">XML Base</em></li>
						<li>and then <xml>xml:id</xml> was added by <link href="xml:id"><code>xml:id</code></link></li>
					</ul>
					<li>When defining namespaces, plan ahead and publish everything</li>
					<ul>
						<li>dependencies, change management, and versioning issues are important</li>
						<li>there still is no established standard for namespace descriptions</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Processing Namespaces</title>
			<slide id="namespace-validity">
				<title>Namespaces and Validity</title>
				<ul>
					<li>Namespaces define an additional layer on top of XML</li>
					<ul>
						<li>they define additional semantics (assignment to namespaces)</li>
						<li>they define additional constraints (declaration and usage of namespaces)</li>
					</ul>
					<li>Namespace-awareness is a basic requirement for XML tools</li>
					<ul>
						<li>XML not compliant with XML Namespaces will break most tools</li>
						<li>processing namespaces should be done by tools</li>
						<li>a namespace-aware parser translates namespace declarations into nodes</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Namespaces in the Document</title>
				<listing src="mathml4.xml"/>
			</slide>
			<slide>
				<title>Namespaces in the Tree</title>
				<img src="xmlns-tree.png" style="width : 90% ; margin : 4% ; "/>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Name Spaces</title>
				<ul>
					<li><q>Bags of Names</q> with a URI as a label</li>
					<li>The URI does not necessarily return anything</li>
					<li>Namespaces can be defined in any way (e.g., schemas)</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xsd-1">
		<title short="XSD 1">XSD – Part I</title>
		<date>2013-09-30</date>
		<toc class="resources"><a href="http://www.w3.org/XML/Schema" title="W3C XML Schema Home">XML Schema</a></toc>
		<toc class="abstract">The <em>XML Schema Definition Language (XSD)</em> is the most popular schema language for XML today. It has been introduced to overcome some of the commonly observed limitations of DTDs, most notably the lack of typing. <em>Simple Types</em> describe content which is not structured by XML markup, which means it describes attribute values and element content. Simple types can be defined by deriving new types from existing types by using type restriction.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>Bad Names</title>
			<blockquote>XML Schema is a language for describing an XML schema.<br/>An XML schema can be defined using XML Schema.<br/>I would like to use XML Schema for my XML schema.</blockquote>
			<ul>
				<li>The two most awkward name choices in the XML arena:</li>
				<ol>
					<li><em>XML Schema</em>, which is simply <u>a</u> XML schema language (among many others)</li>
					<li><em>Open XML</em>, which is simply an XML language for encoding office documents</li>
				</ol>
				<li>Naming things means <q>getting into people's heads</q></li>
				<ul>
					<li>pretentious and all-embracing name choices serve a certain purpose</li>
					<li><em>XSD</em> and <em>WXS</em> are two semi-official acronyms for XML Schema</li>
				</ul>
				<li>Good news: <em>XML Schema</em> <a href="http://dret.typepad.com/dretblog/2008/06/new-w3c-drafts-xsd-rdfa.html">has been renamed</a> (<a href="http://dret.typepad.com/dretblog/2007/08/xml-schema-11-x.html">after being renamed</a>)</li>
				<ul>
					<li><em>XSD</em> now is the official acronym for the <em>XML Schema Definition Language</em></li>
					<li>(very officially, this name change affects version 1.1 of the language only …)</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>What's Wrong With DTDs?</title>
			<ul>
				<li>DTDs do not support application-level datatypes</li>
				<ul>
					<li>XML for B2B is very data-centric and needs typing</li>
					<li>SGML was created for documents where typing was less important</li>
				</ul>
				<li>DTDs do not support any relationships between markup constructs</li>
				<ul>
					<li>content models cannot be reused</li>
					<li>attribute lists cannot be reused</li>
					<li>structural relationships cannot be exploited in the DTD</li>
					<li><link href="param-entity"/> are used as a hack to work around this limitation</li>
				</ul>
				<li>DTD + XML Namespaces = Bad idea!</li>
			</ul>
		</slide>
		<slide>
			<title>Different Levels of Semantics</title>
			<ul>
				<li>XSD's simple data type provide some semantics</li>
				<ul>
					<li>a formerly undescribed attribute can now be described as being a <xsdtype>date</xsdtype></li>
					<li>it can be understood as being a date and inserted into a calendar</li>
					<li>but what kind of date is it? a birthday? an order date? a shipping date?</li>
					<li>a question of the <em>context</em> of where the <xsdtype>date</xsdtype> appears</li>
				</ul>
				<li>XSD better supports model-level information</li>
				<ul>
					<li>however, XSD also only captures part of the application semantics</li>
					<li>XSD is usually more specific than a DTD, because it contains types</li>
					<li>types provide information about the basic datatypes being used</li>
					<li>additional semantics (e.g., different kinds of dates) must be documented elsewhere</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>Schema-Validation and Applications</title>
			<img src="schema-valid-documents.png" style="width : 90% ; margin : 4% ; "/>
		</slide>
		<slide>
			<title>Validation and Typing</title>
			<ul>
				<li>XSD does two things at the same time:</li>
			</ul>
			<ol>
				<li>Validation checks for structural integrity (is the document <em>schema-valid</em>?)</li>
				<ul>
					<li>checking elements and attributes for proper usage (as with DTDs)</li>
					<li>checking element contents and attribute values for proper values</li>
				</ul>
				<li>Type annotations make the types available to applications</li>
				<ul>
					<li>instead of having to look at the schema, applications get the <em>Post-Schema Validation Infoset (PSVI)</em></li>
					<li>type-based applications (such as XSLT 2.0) can work on the typed instance</li>
				</ul>
			</ol>
		</slide>
		<slide>
			<title>XSD Syntax</title>
			<img src="xml-technology-syntaxes.png" style="width : 90% ; margin : 4% ; "/>
		</slide>
		<part id="xsd-types">
			<title>XSD Types</title>
			<slide>
				<title>What is a Type?</title>
				<ul>
					<li>A type is a <em>set of values</em></li>
					<ul>
						<li>the values can be enumerated (<em>home, mobile, office</em>)</li>
						<li>the values can be described by extension (intervals, regular expressions)</li>
					</ul>
					<li>DTD have (almost) no types</li>
					<ul>
						<li>element content is always <xml>#PCDATA</xml> (any number of any characters)</li>
						<li>attributes most often are <xml>CDATA</xml>  (any number of any characters)</li>
						<li>attributes may have enumerated types (but no extensional types)</li>
						<li>attributes may use <link href="ididref"/></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XSD vs. DTD</title>
				<div style="margin : 2% ; ">
					<table width="90%" cellspacing="20">
						<col/>
						<colgroup span="2"/>
						<thead>
							<tr>
								<td/>
								<th>DTD</th>
								<th>XSD</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th>Concepts</th>
								<td colspan="2" align="center">some conceptual model (formal/informal)</td>
							</tr>
							<tr>
								<th>Types</th>
								<td style="color : gray ; "><xml>ID/IDREF</xml> and (<xml>#P</xml>)<xml>CDATA</xml></td>
								<td>Hierarchy of Simple and Complex Types</td>
							</tr>
							<tr>
								<th>Markup Constructs</th>
								<td>Element Type Declarations<br/><xml>&lt;!ELEMENT order …</xml></td>
								<td>Element Definitions<br/><xml>&lt;xs:element name="order"> …</xml></td>
							</tr>
							<tr>
								<th>Instances (Documents)</th>
								<td colspan="2" align="center"><xml>&lt;order date=""> [ order content ] &lt;/order></xml></td>
							</tr>
						</tbody>
					</table>
				</div>
			</slide>
			<slide>
				<title>Document/Data Perspectives</title>
				<ul>
					<li>XML as documents is text interspersed with structure</li>
					<ul>
						<li>XML captures text structures that support document processing</li>
						<li>without these structures, the text remains usable (as unstructured text)</li>
						<li>structure is good, but not indispensable</li>
					</ul>
					<li>XML as data is structure filled with data</li>
					<ul>
						<li>programmers think about classes and objects, so they need types</li>
						<li>without structure, data-centric XML is completely useless</li>
						<li>programmers often view XML as wire format and types as the portal to their objects</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="xsd-simple-types">
			<title>Simple Types</title>
			<slide>
				<title>What are Simple Types?</title>
				<ul>
					<li>Simple types describe values not structured by XML markup</li>
					<ul>
						<li>they describe attribute values (<xml>date="2006-10-03"</xml>)</li>
						<li>they describe element content (<code>&lt;phone>+1-510-6432253&lt;/phone></code>)</li>
					</ul>
					<li>Simple types can be used for elements or attributes</li>
					<ul>
						<li>XSD treats contents in elements and attributes equally</li>
						<li>simple type libraries can be designed independent of their eventual use</li>
					</ul>
					<li>Simple types are available in three flavors</li>
					<ul>
						<li><em>atomic types:</em> one value of one type (one number in some range)</li>
						<li><em>union types:</em> one value of a union of types (a number or the string <q><code>undefined</code></q>)</li>
						<li><em>list types:</em> a whitespace-separated list of values (<elem>phone type="home office"</elem>)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Named vs. Anonymous</title>
				<ul>
					<li>Types can be <em>named</em> or <em>anonymous</em></li>
					<ul>
						<li>named types have a name and can be referenced (and thus be reused)</li>
						<li>anonymous types have no name and can only be used where they are defined</li>
					</ul>
				</ul>
				<listing src="named-anonymous-simple.xsd" line="3-9"/>
				<listing src="named-anonymous-simple.xsd" line="17-23"/>
			</slide>
			<slide>
				<title>Type Definitions</title>
				<ul>
					<li>Simple types are sets of values</li>
					<ul>
						<li>named simple types are sets of values with a name (and thus reusable)</li>
						<li>anonymous simple types are sets of values defined where they are needed</li>
					</ul>
					<li>Simple types are defined to represent model-level information</li>
					<ul>
						<li>in most cases, they will have restrictions associated with them</li>
						<li>they may also simply be tags for semantics (fax and phone numbers share the same value space)</li>
					</ul>
					<li>XSD has a library of <em>built-in datatypes</em></li>
					<ul>
						<li><em>ur-types</em> are the conceptual grounding of all types</li>
						<li><em>primitive types</em> are the types that are there <q>by definition</q></li>
						<li><em>derived types</em> are based on primitive types</li>
						<li>users can derive their own types using <link href="xsd-simple-type-restriction"/></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Type Hierarchy</title>
				<img style="height : 75% ; margin : 2% ; " src="xsd-type-hierarchy.gif" href="http://www.w3.org/TR/xmlschema-2/#built-in-datatypes"/>
			</slide>
			<part id="xsd-simple-type-restriction">
				<title>Simple Type Restriction</title>
				<slide>
					<title>Built-In Types</title>
					<listing src="built-in.xsd"/>
				</slide>
				<slide>
					<title>How to Restrict</title>
					<ul>
						<li>Simple types can be derived by restriction</li>
						<ul>
							<li>the <em>base type</em> must be a simple type</li>
							<li>the <em>derived type</em> will be a simple type</li>
							<li>all simple types form a tree, rooted at the <code>anySimpleType</code></li>
						</ul>
						<li>Restriction are based on facets</li>
						<ul>
							<li>each restriction can use <em>0-n</em> facets</li>
							<li>facets can be refined in further simple type restrictions</li>
							<li>XSD designers should try to restrict types as much as possible</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Facets</title>
					<ul>
						<li>Facets define a certain way of restricting a simple type</li>
						<ul>
							<li>facets are independent, but they may interact (<code>minLength</code> and <code>maxLength</code>)</li>
							<li>XSD defines 12 <em>constraining facets</em> which may be used for restrictions</li>
							<li><code>length, minLength, maxLength, pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minExclusive, minInclusive, totalDigits, fractionDigits</code></li>
						</ul>
						<li>Facets may be repeated in different levels of the type hierarchy</li>
						<ul>
							<li>they may only further restrict the facet (e.g., reducing the <code>maxLength</code>)</li>
							<li>facets apply to all directly or indirectly derived subtypes</li>
							<li>facets may be <em>fixed</em> (no further restriction is allowed)</li>
						</ul>
						<li>Not all facets are applicable to all types</li>
						<ul>
							<li>the applicability depends on the <em>primitive type</em> being used</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Facet Applicability</title>
					<div style="margin : 2% ; ">
						<table width="90%">
							<tr>
								<th align="right" valign="top"><code>string</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>boolean</code></th>
								<td>pattern, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>float</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>double</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>decimal</code></th>
								<td>totalDigits, fractionDigits, pattern, whiteSpace, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>duration</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>dateTime</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>time</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>date</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gYearMonth</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gYear</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gMonthDay</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gDay</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gMonth</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>hexBinary</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>base64Binary</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>anyURI</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>QName</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>NOTATION</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
						</table>
					</div>
				</slide>
				<slide>
					<title>Patterns</title>
					<ul>
						<li>Patterns restrict the <em>lexical space</em> of simple types</li>
						<ul>
							<li>most other facets restrict the <em>value space</em> (e.g., intervals of numbers)</li>
							<li>in many cases, patterns are useful additions to value-oriented facets</li>
						</ul>
						<li>Patterns are <a href="http://www.w3.org/TR/xmlschema-2/#regexs">regular expressions</a></li>
						<ul>
							<li>they support many common regex constructs and Unicode</li>
							<li>the language pattern allows <q><code>de</code></q>, <q><code>de-CH</code></q>, and other tags</li>
							<li>the pattern checks for lexical correctness, not against a code list</li>
						</ul>
					</ul>
					<pre>([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]{1,8})(-[a-zA-Z]{1,8})*</pre>
				</slide>
				<slide>
					<title>Simple Type Examples</title>
					<listing src="simple-examples.xsd"/>
				</slide>
				<slide>
					<title>Facet Limitations</title>
					<ul>
						<li>Facets limit one dimension of a type's value space</li>
						<ul>
							<li>using <code>pattern</code>, the lexical space can also be restricted</li>
							<li>restrictions should be made as specific as possible</li>
							<li>no limitations are possible beyond the predefined facets</li>
						</ul>
						<li>There is no connection to the context within the document</li>
						<ul>
							<li>facets cannot make references to other values (e.g., neighboring attributes)</li>
						</ul>
						<li>Additional constraints should be documented</li>
						<ul>
							<li>documentation enables applications to implement constraint checking</li>
							<li>other schema languages (like <a href="http://dret.net/lectures/xml-fall08/schemalanguages">Schematron</a>) may be used to express these constraints</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Typed XML Content</title>
				<ul>
					<li>XSD introduces a <q>type layer</q> to schema languages</li>
					<li>Types facilitate abstractions (and thus modeling)</li>
					<li>Simple types can be restricted to yield more specific types</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xsd-2">
		<title short="XSD 2">XSD – Part II</title>
		<date>2013-10-02</date>
		<toc class="resources"></toc>
		<toc class="abstract">XSD <em>Complex Types</em> describe element content if this content is using attributes and/or element content other than only character data. Thus, complex types are used to define the allowed markup structures for a class of documents. Using XSD's type concepts, it is easier to represent model-level information in a schema, because type hierarchies can represent model-level specializations.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part id="xsd-complex-types">
			<title>Complex Types</title>
			<slide>
				<title>What is a Complex Type?</title>
				<ul>
					<li>Complex types describe the allowed element content</li>
					<ul>
						<li>they describe what the element may contain (the element's <em>content model</em>)</li>
						<li>they describe the attributes that an element may have (the element's <em>attribute list</em>)</li>
					</ul>
					<li>Complex types do not define the element name</li>
					<ul>
						<li>the complex type defines which content is allowed for the element</li>
						<li>the element definition uses the complex type to define the allowed element content</li>
					</ul>
					<li>Complex types have similar properties to simple types</li>
					<ul>
						<li>they can be named or anonymous</li>
						<li><link href="xsd-complex-type-derivation"/> can be used to construct a type hierarchy</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Complex Type Example</title>
				<listing src="complex-example.xsd"/>
			</slide>
			<slide>
				<title>Complex Types &amp; Content Types</title>
				<ul>
					<li>Complex types can have different kinds of content</li>
					<ul>
						<li><em>simple content</em> refers to simple type content using additional attributes</li>
						<li><em>complex content</em> is anything else (anything beyond <em>simple type content</em>)</li>
					</ul>
					<li><link href="xsd-complex-type-derivation"/> heavily depends on this classification</li>
				</ul>
				<div style="margin : 2% ; ">
					<table width="90%" cellspacing="20" rules="all" frame="border">
						<tr>
							<th rowspan="3">Simple Types</th>
							<th colspan="4">Complex Types</th>
						</tr>
						<tr>
							<th rowspan="2">Simple Content</th>
							<th colspan="3">Complex Content</th>
						</tr>
						<tr>
							<td align="center">Element Only</td>
							<td align="center">Mixed</td>
							<td align="center">Empty</td>
						</tr>
					</table>
				</div>
			</slide>
			<part>
				<title>Content Models</title>
				<slide>
					<title>DTD Content Models</title>
					<ul>
						<li><link href="dtd-element"/> in DTDs uses a compact syntax</li>
						<ul>
							<li>XSD supports the same facilities with a more verbose syntax</li>
							<li>XSD adds features which DTDs do not support</li>
						</ul>
						<li>DTDs allow elements to be mandatory, optional, repeatable, or optional and repeatable</li>						
						<ul>
							<li>XSD allows the cardinality to be specified</li>
						</ul>
						<li>DTDs allow sequences (<q><code>,</code></q>) and alternatives (<q><code>|</code></q>)</li>
						<ul>
							<li>XSD introduces a (very limited) operator for <em>all groups</em></li>
						</ul>
						<li>Apart from the syntax, XSD content models are not very different</li>
					</ul>
				</slide>
				<slide>
					<title>Mixed Content</title>
					<ul>
						<li>DTDs define mixed content by mixing <code>#PCDATA</code> into the content model</li>
						<ul>
							<li>DTDs always require mixed content to use the form <code>( #PCDATA | a | b )*</code></li>
							<li>the occurrence of elements in mixed content cannot be controlled</li>
						</ul>
						<li>XSD defines mixed content outside of the content model</li>
						<ul>
							<li>the content model is defined like an element-only content model</li>
							<li>the <code>mixed</code> attribute on the type marks the type as being mixed</li>
						</ul>
						<li>XSD mixed content can use all model groups</li>
						<ul>
							<li>it is possible to constrain element occurrences in the same way as in element-only content</li>
							<li>in practice, this feature is rarely used (mixed content often is very loosely defined)</li>
						</ul>
					</ul>
					<listing src="global-local.xsd" line="3-11"/>
				</slide>
				<slide>
					<title>Empty Content</title>
					<ul>
						<li>DTDs have a special keyword for empty elements</li>
						<ul>
							<li>instead of the content model, the keyword <code>EMPTY</code> is used</li>
							<li>empty elements may still have attribute lists associated with them</li>
						</ul>
						<li>XSD empty types are defined implicitly</li>
						<ul>
							<li>there is no explicit keyword for defining an empty type</li>
							<li>if a type has no model group inside it, it is empty (it still may have attributes)</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>XSD Design Patterns</title>
			<slide>
				<title>Global Elements? Named Types?</title>
				<ul>
					<li>XSD's design dimensions allow different strategies</li>
					<li>Elements/attributes can be defined as <em>local</em> or <em>global</em></li>
					<ul>
						<li><em>local</em> elements/attributes are defined where they are used</li>
						<li><em>global</em> elements/attributes are globally defined and then referenced</li>
						<li>elements/attributes which should be reused must be defined as global</li>
					</ul>
					<li>Types can be defined as <em>anonymous</em> or <em>named</em></li>
					<ul>
						<li><em>anonymous</em> types are defined where they are used</li>
						<li><em>named</em> types are globally defined and then referenced</li>
						<li>types which should be reused must be defined as named</li>
					</ul>
					<li>XSD design patterns can favor one type of definition</li>
					<ul>
						<li>reuse always required <em>global</em> elements/attributes and <em>named</em> types</li>
						<li>having everything <em>global/named</em> results in bigger schema</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Sample XML</title>
				<listing src="design-sample.xml"/>
			</slide>
			<part>
				<title>Russian Doll</title>
				<slide>
					<title>Russian Doll XSD</title>
					<listing src="russian-doll.xsd"/>
				</slide>
				<slide>
					<title>Russian Doll Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="russian-doll.gif" title="Russian Doll XSD"/>
				</slide>
			</part>
			<part>
				<title>Venetian Blinds</title>
				<slide>
					<title>Venetian Blinds XSD</title>
					<listing src="venetian-blinds.xsd"/>
				</slide>
				<slide>
					<title>Venetian Blinds Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="venetian-blinds.gif" title="Venetian Blinds XSD"/>
				</slide>
			</part>
			<part>
				<title>Salami Slice</title>
				<slide>
					<title>Salami Slice XSD</title>
					<listing src="salami-slice.xsd"/>
				</slide>
				<slide>
					<title>Salami Slice Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="salami-slice.gif" title="Salami Slice XSD"/>
				</slide>
			</part>
			<part>
				<title>Garden of Eden</title>
				<slide>
					<title>Garden of Eden XSD</title>
					<listing src="garden-of-eden.xsd"/>
				</slide>
				<slide>
					<title>Garden of Eden Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="garden-of-eden.gif" title="Garden of Eden XSD"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Local and Global Definitions</title>
			<slide>
				<title>Named and Anonymous Types</title>
				<ul>
					<li>Types can be named or anonymous</li>
					<ul>
						<li>named types can be reused (for elements, attributes, or type derivation)</li>
						<li>anonymous types can only be used where they are defined</li>
					</ul>
					<li>DTD <q>types</q> are always anonymous (they cannot be reused)</li>
				</ul>
				<pre>&lt;!ELEMENT person <span style="color : red ; ">(name, address) >
&lt;!ATTLIST person id ID #REQUIRED ></span></pre>
				<ul>
					<li>DTDs have everything hardcoded</li>
					<ul>
						<li>complex types are always locally defined</li>
						<li>elements are always globally defined</li>
						<li>attributes are always locally defined</li>
					</ul>
				</ul>
			</slide>
			<part>
				<title>Elements</title>
				<slide>
					<title>Local vs. Global Elements</title>
					<ul>
						<li>Elements can be defined in a type or in the schema</li>
						<ul>
							<li>local elements can only be used where they are defined</li>
							<li>global elements can be reused, they can serve as building blocks</li>
						</ul>
						<li>Elements and complex types depend on each other</li>
						<ul>
							<li>an element is defined by a type, often this will be a complex type</li>
							<li>a complex type is defined by its contents, which are elements and/or attributes</li>
						</ul>
					</ul>
					<listing src="global-local.xsd" line="4-12"/>
				</slide>
				<slide>
					<title>Reusable Elements</title>
					<listing src="complex-example.xsd"/>
				</slide>
			</part>
			<part>
				<title>Attributes</title>
				<slide>
					<title>Attribute Definitions</title>
					<ul>
						<li>DTDs treat attributes as something entirely different from element content</li>
						<ul>
							<li>they are defined in an <code>ATTLIST</code>, not in the <code>ELEMENT</code> definition</li>
							<pre>&lt;!ELEMENT person (name, address) >
<span style="color : red ; ">&lt;!ATTLIST person id ID #REQUIRED ></span></pre>
							<li>they have a special range of <link href="dtd-attr-type"/> as opposed to elements</li>
							<pre>&lt;!ATTLIST person id <span style="color : red ; ">ID</span> #REQUIRED ></pre>
						</ul>
						<li>XSD overcomes these restrictions only partially</li>
						<ul>
							<li><link href="xsd-simple-types"/> are used to define attribute (or element) contents</li>
							<li>attributes are still described as something entirely different from an element's content model</li>
						</ul>
						<li>Attributes could be better integrated into the model</li>
						<ul>
							<li><a href="http://dret.net/lectures/xml-fall08/schemalanguages#%287%29">RELAX NG</a> treats attributes as part of an element's content model</li>
							<li>this makes it trivial to have choices of element content and attributes</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Reusing Attributes</title>
					<ul>
						<li>DTDs treat attributes as something local to an element</li>
						<ul>
							<li>attributes are defined in an element's <code>ATTLIST</code></li>
							<li>reusing attributes for more than on element requires <link href="param-entity"/></li>
						</ul>
						<li>XSD better supports reuse of schema components</li>
						<ul>
							<li>types can be defined locally (anonymous) or globally (named)</li>
							<li>elements and attributes can be defined globally or locally</li>
						</ul>
						<li>Globally defined attributes can be reused</li>
						<ul>
							<li>the attribute definition does not tie it to any occurrence</li>
							<li>the attribute can then be referenced from an complex type definition</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Reusing Attributes (Example)</title>
					<listing src="global-local.xsd"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Typed XML Structures</title>
				<ul>
					<li>XSD introduces a <q>type layer</q> to schema languages</li>
					<li>Types facilitate abstractions (and thus modeling)</li>
					<li>Complex types define how elements have to be used</li>
					<li>Designing XSD can be done in many different ways</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xsd-3">
		<title short="XSD 3">XSD – Part III</title>
		<date>2013-10-07</date>
		<toc class="resources"><a href="http://www.awprofessional.com/articles/printerfriendly.asp?p=31477&amp;rl=1">XSD Identity Constraints</a></toc>
		<toc class="abstract">XSD allows greater flexibility in defining constraints on intra-document references than the ID/IDREF construct of DTDs. XSD's <em>Identity Constraints</em> are scoped, typed, and can be used for elements or attributes. They are more powerful that the DTD's limited ID/IDREF mechanism, but still lack sufficient generality to support a really wide set of model constraints to be expressed. XSD complex types can be derived by <em>restriction</em> or <em>extension</em>. Complex type restriction defines the restricted type to be a more restricted version of the base type. Complex type extension make it possible to extend the base type by either adding attributes or contents (only by appending new content to the content model). Complex type derivation allows XSD to express type hierarchies of complex types, which can be aligned with more or less specialized code for processing instances of these types.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part id="xsd-names">
			<title>Names and Namespaces</title>
			<slide>
				<title>Definitions</title>
				<ul>
					<li>Many XSDs define a vocabulary for a namespace</li>
					<ul>
						<li>DTDs do not have any support for namespaces</li>
						<li>XSD heavily builds on <link href="xmlns"/></li>
					</ul>
					<li>XSD provides support for declaring a vocabulary's namespace</li>
					<pre>&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" <span style="color : red ; ">targetNamespace="http://www.example.com/"</span>></pre>
					<li>Schema-validation can check for proper namespace usage</li>
					<ul>
						<li>the <xml>targetNamespace</xml> has to be used in the instance</li>
						<li>if the namespace does not match, validation cannot succeed</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Instances</title>
				<ul>
					<li>The schema defines the <xml>targetNamespace</xml> of the vocabulary</li>
					<ul>
						<li>all globally defined elements, attributes, and types are in that namespace</li>
						<li>the instances must declare and use the namespace to be schema-valid</li>
					</ul>
				</ul>
				<listing src="multicol.html" line="2-5"/>
				<ul>
					<li>A <em>prefixed name</em> is not the same as a <em>qualified name</em></li>
					<ul>
						<li>if there is a default namespace, unprefixed elements are still qualified</li>
					</ul>
					<li>Nasty details about XML Namespaces and attributes</li>
					<ul>
						<li>the default namespace does <em>not</em> apply to attributes</li>
						<li>attributes must therefore <em>always be prefixed</em> if they need to be qualified</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Name Qualification</title>
				<ul>
					<li>Global elements and attributes have to be used as qualified names</li>
					<ul>
						<li>this means that they must be referred to by their namespace-qualified name</li>
						<li>if a default namespace is used, elements are qualified <em>without carrying a prefix</em></li>
						<li>since the default namespace does not apply to attributes, they always must be explicitly prefixed</li>
					</ul>
					<li>Local elements and attributes may be used qualified or unqualified</li>
					<ul>
						<li>this control <em>only applies to locally define elements or attributes</em></li>
						<li>the default defined by XSD is not a good choice</li>
						<li>because of how XML Namespaces work, a non-default choice is recommended</li>
					</ul>
					<li>XSD allows control over how local names have to be used</li>
				</ul>
				<pre>&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.com/" <span style="color : red ; ">elementFormDefault="qualified" attributeFormDefault="unqualified"</span>></pre>
			</slide>
		</part>
		<part>
			<title>Identity Constraints</title>
			<slide>
				<title>Element = Type + Constraints</title>
				<ul>
					<li>DTDs and XSD are mainly about specifying grammars</li>
					<ul>
						<li>types describe the allowed values using grammars</li>
						<li>grammar-oriented schemas have some nice properties</li>
					</ul>
					<li>DTD's <link href="ididref"/> allow additional constraints</li>
					<ul>
						<li>apart from the grammar definition, cross-references in the tree are supported</li>
						<li>validation checks the integrity of the cross-references, not only the tree</li>
					</ul>
					<li>DTD's ID/IDREF are a very simple mechanism</li>
					<ul>
						<li>they are always global</li>
						<li>they also define the type of the attribute (XML names)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Improvements over ID/IDREF</title>
				<ul>
					<li>XSD's <em>Identity Constraints</em> improve DTD's ID/IDREF</li>
					<li>Identity constraints are scoped and apply only to a selected set of nodes</li>
					<ul>
						<li>the constraint applies only to a selected set of nodes (using XPath)</li>
					</ul>
					<li>Identity constraints are evaluated using typed values</li>
					<ul>
						<li><code>ID</code>s must be XML names (no numbers allowed)</li>
						<li><q><code>2</code></q> ≟ <q><code>+00002</code></q> should be evaluated based on the type (string or decimal?)</li>
						<li>XSD separates the constraint from the type of the selected nodes</li>
					</ul>
					<li>Identity constraints may select elements or attributes</li>
					<ul>
						<li>XPaths are used to select the constrained values, they can select elements or attributes</li>
					</ul>
					<li>Multiple fields</li>
					<ul>
						<li>it is possible to select more than one field for a constraint (phone &amp; area code must be unique)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Types of Identity Constraints</title>
				<ul>
					<li>Uniqueness constraints</li>
					<ul>
						<li>if there is a field, it must have a unique value among the selected nodes</li>
					</ul>
					<li>Key constraints</li>
					<ul>
						<li>there must be a field, and it must have a unique value among the selected nodes</li>
					</ul>
					<li>Key reference constraints</li>
					<ul>
						<li>the field must refer to an existing value in the referred key</li>
						<li>if the key reference also is constrained by a key, only one reference may use the referred key</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Identity Constraint Definitions</title>
				<ul>
					<li>Identity constraints are part of an element definition</li>
					<li>There are <em>three important factors</em> to an identity constraint</li>
					<ol>
						<li>location of the identity constraint's definition</li>
						<li>the nodes to which the constraint should be applied</li>
						<li>the fields which are used to evaluate the constraint</li>
					</ol>
					<li>If the constraint is a key reference constraint, there is a <em>fourth factor</em></li>
					<ol start="4">
						<li>the key constraint that is used for checking the references</li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>Identity Constraint Evaluation</title>
				<img style="width : 90% ; margin : 4% ; " src="identity-constraints.png"/>
			</slide>
			<slide>
				<title>Advanced Identity Constraints</title>
				<img style="width : 90% ; margin : 4% ; " src="identity-constraints++.png"/>
			</slide>
		</part>
		<part id="xsd-complex-type-derivation">
			<title>Complex Type Derivation</title>
			<slide>
				<title>Types in XSD</title>
				<ul>
					<li><link href="xsd-simple-types"/> are used to model non-markup values</li>
					<li><link href="xsd-simple-type-restriction"/> is used to define simple user types</li>
					<li><link href="xsd-complex-types"/> are used to model markup structures</li>
					<li>Models often use generalization and specialization</li>
					<ul>
						<li>not all models use this modeling technique</li>
						<li>OO methods have made this very popular (UML is OO)</li>
					</ul>
					<li><link href="xsd-complex-type-derivation"/> is used to represent model hierarchies</li>
					<ul>
						<li>in theory, this could be used by generalized and specialized code</li>
						<li>in practice, the connection between XSD and code is too weak to be robust</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Type Derivation</title>
				<ul>
					<li>XSD supports the modeling approach of <em>specialization</em></li>
					<ul>
						<li>simple types can be restricted to create more specialized simple types</li>
						<li>each value of a restricted type is also a valid value of the more general type</li>
					</ul>
					<li>Complex types are combinations of content and attributes</li>
					<li>Specialization of complex types can be done in two ways</li>
					<ul>
						<li><link href="xsd-complex-type-restriction"/>: more restricted ways of using the content and/or attributes</li>
						<li><link href="xsd-complex-type-extension"/>: additional content and/or attributes may be used</li>
					</ul>
					<li>Both kinds of complex type derivation can be regarded as specialization</li>
					<ul>
						<li><link href="xsd-complex-type-restriction"/>: for US persons the country must always be set to <q><code>US</code></q></li>
						<li><link href="xsd-complex-type-extension"/>: people having an employee number are employees</li>
					</ul>
				</ul>
			</slide>
			<part id="xsd-complex-type-restriction">
				<title>Complex Type Restriction</title>
				<slide>
					<title>Removing Choices</title>
					<ul>
						<li>Complex types usually allow variability</li>
						<ul>
							<li><xml>minOccurs</xml> and <xml>maxOccurs</xml> allow variability in occurrences</li>
							<li><xml>choice</xml> groups allow to choose between a number of alternatives</li>
							<li>attributes may be flagged as <code>use="optional"</code></li>
							<li>simple types allow the individual values to use certain sets of values</li>
						</ul>
						<li>Complex type restriction allows restrictions of all these variations</li>
						<ul>
							<li><xml>minOccurs</xml> and <xml>maxOccurs</xml> can be made more restrictive</li>
							<li>alternatives can be removed from choice groups</li>
							<li>optional attributes can flagged as <code>use="required"</code> or <code>use="prohibited"</code></li>
							<li>the simple types of values can be set to more restricted simple types</li>
						</ul>
						<li>The technical way of defining restrictions is cumbersome</li>
						<ul>
							<li>when the base type changes, the restricted type has to be fixed by hand</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Complex Type Restriction (Example)</title>
					<listing src="complex-restriction.xsd"/>
				</slide>
				<slide>
					<title>Processing Restricted Complex Types</title>
					<ul>
						<li>Values of restricted types are values of the base types</li>
						<ul>
							<li>type restriction is defined so that restricted type values are always base type values</li>
							<li>code processing a type can be reused to process restricted types</li>
						</ul>
						<li>If there is a well-designed type hierarchy, programming becomes easier</li>
						<ul>
							<li>simple code can be written to handle the basic types</li>
							<li>if required, more advanced code can be written for the restricted types</li>
							<li>in many cases, restriction is more for validation than for processing</li>
						</ul>
						<li>XSDs may even use <em>abstract types</em></li>
						<ul>
							<li>no element will ever use the <xml>addressType</xml></li>
							<li>concrete elements will only use restricted types</li>
							<li>there can be code handling the <xml>addressType</xml> which handles all addresses</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xsd-complex-type-extension">
				<title>Complex Type Extension</title>
				<slide>
					<title>Adding Content</title>
					<ul>
						<li>Complex types are element content and attributes</li>
						<ul>
							<li>extensions can add content, but only at the end of the base content</li>
							<li>extensions can add attributes (order is not significant for attributes)</li>
						</ul>
						<li>Adding content to existing content may not change the existing content</li>
						<ul>
							<li>if the content is <em>element only</em>, it has to remain element only</li>
							<li>if the content is <em>mixed</em>, is has to remain mixed</li>
							<li>if the content is <em>empty</em>, it may become element only or mixed</li>
							<li>the reason for these rules is that <em>mixed</em> is a global property of a type</li>
						</ul>
						<li>Adding attributes simply adds these to the list of existing attributes</li>
						<ul>
							<li>the added attributes may be optional or required</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Complex Type Extension (Example)</title>
					<listing src="complex-extension.xsd"/>
				</slide>
				<slide>
					<title>Processing Extended Complex Types</title>
					<ul>
						<li>Values of extended types are <em>not</em> values of the base types</li>
						<ul>
							<li>type extension adds content add/or attributes to a type</li>
							<li>if content is added, it is always added at the end of the base type's content</li>
						</ul>
						<li>If there is a well-designed type hierarchy, programming becomes easier</li>
						<ul>
							<li>simple code can be written to handle the basic types</li>
							<li>if that should handle extended types, it must be written to handle extensions</li>
							<li><q>handling extensions</q> can be as simple as skipping them</li>
						</ul>
						<li>XSDs may even use <em>abstract types</em></li>
						<ul>
							<li>no element will ever use the <xml>addressType</xml></li>
							<li>concrete elements will only use extended types</li>
							<li>code handling extended types can build on code handling the base type</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XSD Features</title>
				<ul>
					<li>XSD allows defining a grammar for XML documents</li>
					<li>Identity constraints enable non-grammar constraints to be expressed</li>
					<li>XSD identity constraints are more powerful than the DTD ID/IDREF concept</li>
					<li>Only a subset of structural constraints can be expressed in XSD</li>
					<li>XSD 1.1 introduces the concept of <em>assertions</em> (XPath-based constraints)</li>
					<li>Types make it easier to turn a model into a grammar</li>
					<li>Some of the things we have not seen:</li>
					<ul>
						<li>named groups, modularizing schemas, wildcards, substitution groups, …</li>
					</ul>
				</ul>
			</slide>
			<slide id="schema-components">
				<title>Schema Components</title>
				<img style="height : 75% ; margin : 2% ; " src="schema-components.gif" title="Schema Components"/>
			</slide>
		</part>
	</presentation>
	<presentation id="presentation-preparation" external="project-schedule#preparation">
		<title>Project Presentation Preparation</title>
		<date>2013-10-09</date>
	</presentation>
	<presentation id="presentations" external="project-schedule#presentation">
		<title>Project Presentations</title>
		<date>2013-10-14</date>
	</presentation>
	<presentation id="presentation-preparation" external="project-schedule#feedback">
		<title>Project Presentation Feedback</title>
		<date>2013-10-16</date>
	</presentation>
	<presentation id="xslt-1">
		<title short="XSLT 1">XML Transformations (XSLT) – Part I</title>
		<date>2013-10-21</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xslt" title="W3C XSLT 1.0 Specification">Spec</a></toc>
		<toc class="abstract">Because XML can be used to represent any vocabulary (often defined by some schema), the question is how these different vocabularies can be processed and maybe transformed into something else. This <q>something else</q> may be another XML vocabulary (a common requirement in B2B scenarios), or it may be HTML (a common scenario for Web publishing). Using <em>XSL Transformations (XSLT)</em>, mapping tasks can be implemented easily. XSLT leverages XPath's expressive power in a rather simple programming language, the programs are often called <em>stylesheets</em>. For easy tasks, XSLT mappings can be specified without much real <q>programming</q> going on, by simply specifying how components of the source markup are mapped to components of the target markup.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>XPath and XSLT</title>
			<ul>
				<li>XPath is an expression language</li>
				<ul>
					<li>location paths let you select parts of an XML document tree</li>
					<li>expressions in general may have other data types as well (string, number, boolean)</li>
				</ul>
				<li>XSLT is a programming language based on XPath</li>
				<ul>
					<li>XSLT defines the structures for the control flow within the program</li>
					<li>in all the places where something is evaluated, XPaths are being used</li>
					<li>sometimes, one can substitute for the other</li>
				</ul>
			</ul>
			<listing src="xslt-vs-xpath.xsl" line="5-13"/>
		</slide>
		<slide>
			<title>XSLT Executive Summary</title>
			<ul>
				<li>XSLT is an XML-oriented programming language</li>
				<li>XSLT uses XML as its syntax</li>
				<li>XSLT is a weakly typed language</li>
				<li>XSLT is not designed for large programming tasks</li>
				<li>XSLT is the standard language for XML-to-XML transformations</li>
				<li>XSLT is very simple and often too simple</li>
				<li><link href="xslt20-1">XSLT 2.0</link> is much more complex and powerful</li>
			</ul>
		</slide>
		<slide>
			<title>XSLT as a Programming Language</title>
			<ul>
				<li>XSLT is a functional programming language</li>
				<ul>
					<li>fundamentally different from the usual languages</li>
					<li>not important for very simple mapping applications</li>
					<li>important for writing more complex transformations</li>
					<li>hard to get used to for procedurally trained people</li>
				</ul>
				<li>XSLT has built-in behavior for tree traversal</li>
				<ul>
					<li>XPaths allows you to select parts of the document tree</li>
					<li>XSLT's default behavior is to traverse the complete tree</li>
					<li>the idea of <q>default behavior</q> may seem strange</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>XSLT Processing Model</title>
			<img src="xslt-model.png" style="width : 90% ; margin : 2% ; "/>
		</slide>
		<part id="xslt-examples">
			<title>Simple Examples</title>
			<slide>
				<title>My First XSLT</title>
				<ul>
					<li>XSLT uses a simple environment</li>
					<ul>
						<li>all you need is an <em>XSLT processor</em> (<a href="http://www.saxonica.com/">Saxon</a> recommended)</li>
					</ul>
					<li>Some interesting observations</li>
					<ul>
						<li>it is an XML document (using the <a href="http://www.w3.org/TR/xslt#xslt-namespace">XSLT Namespace</a>)</li>
						<li>it contains no visible code (no statements)</li>
						<li>when being applied (i.e., executed), it produces a result</li>
					</ul>
				</ul>
				<listing src="first.xsl"/>
			</slide>
			<slide>
				<title>Why does it Work?</title>
				<ul>
					<li>The <q>text</q> of the document is produced</li>
					<ul>
						<li>technically, it is the concatenation of all text nodes</li>
						<li>this works with all XML input documents</li>
					</ul>
					<li>XSLT by default traverses the document tree</li>
					<ul>
						<li>it copies all text nodes</li>
						<li>it works its way through the document recursively</li>
						<li>this behavior is unusual for a programming language</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>My Second XSLT</title>
				<listing src="second.xsl" line="3-21"/>
			</slide>
			<slide>
				<title>How Mappings Work</title>
				<ul>
					<li>All non-XSLT elements are <em>literal result elements</em></li>
					<ul>
						<li>their content is processed as usual</li>
						<li>they may contain XSLT or literal result elements</li>
					</ul>
					<li>XSLT elements in the stylesheet are instructions</li>
					<ul>
						<li>they are executed and have some predefined behavior</li>
						<li>if they produce results, these go to the result tree as well</li>
					</ul>
					<li>One-template XSLT is a good way to start with XSLT</li>
					<ul>
						<li>avoiding the learning curve associated with <link href="xslt-templates"/></li>
						<li>for easy mapping tasks, this pattern often is sufficient</li>
						<li>for complex tasks, this is the XSLT equivalent of <q>spaghetti code</q></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title><q>Hello World</q> in XSLT</title>
				<ul>
					<li>XSLT always transforms an XML document</li>
					<ul>
						<li>this is hard-coded in the <link href="xslt-processing-model"/></li>
					</ul>
					<li>Simply generating output is impossible</li>
					<ul>
						<li><q>hello world</q> therefore ignores the input</li>
						<li>anything can be the input (including the XSLT itself)</li>
					</ul>
				</ul>
				<listing src="helloworld.xsl"/>
			</slide>
		</part>
		<part>
			<title>XSLT Instructions</title>
			<slide>
				<title>XSLT is Simple</title>
				<ul>
					<li>XSLT has a <a href="http://www.w3.org/TR/xslt#element-syntax-summary">small set of instructions</a></li>
					<ul>
						<li>the language was designed to run in a restricted environment</li>
						<li>the language was designed for a specific task</li>
						<li>much of the language's power lies in XPath</li>
					</ul>
					<li>XPath is the complex part of XSLT</li>
					<ul>
						<li>XPath is a complex high-level language</li>
						<li>it is specialized for the task the language is designed to do</li>
						<li>it can be highly optimized</li>
						<li>writing XPaths often is the most challenging part of XSLT</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-iterations">
				<title>Iterations</title>
				<ul>
					<li>XSLT can only iterate over node sets</li>
					<ul>
						<li>any other problem has to be solved recursively</li>
						<li>iterating over node sets often is what you want to do</li>
					</ul>
					<li>Applying the same code to all of the nodes</li>
					<ul>
						<li>works great if all nodes require the same processing</li>
						<li>is of limited use when processing needs to be conditional</li>
					</ul>
				</ul>
				<listing src="second.xsl" line="11-17"/>
			</slide>
			<slide id="xslt-conditionals">
				<title>Conditional Instructions</title>
				<ul>
					<li>Programming languages usually provide if-then-else</li>
					<ul>
						<li>XSLT has an if-then: <xslte>if</xslte></li>
						<li>and an if-then-(elif-then)*-else: <xslte>choose</xslte></li>
					</ul>
					<li>Simple handling of special cases</li>
					<ul>
						<li>having few and reasonably sized conditionals is ok</li>
						<li>having deeply nested and very long conditionals is a problem</li>
						<li>as in all programming languages, the latter case should user other mechanisms</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>My Second XSLT (II)</title>
				<listing src="second-if.xsl" line="10-22"/>
			</slide>
			<slide>
				<title>My Second XSLT (III)</title>
				<listing src="second-choose.xsl" line="20-38"/>
			</slide>
		</part>
		<part id="xslt-templates">
			<title>Templates</title>
			<slide id="xslt-processing-model">
				<title>XSLT Processing Model</title>
				<img src="xslt-model.png" style="width : 90% ; margin : 2% ; "/>
			</slide>
			<slide>
				<title>Templates as Building Blocks</title>
				<ul>
					<li>Templates are the main unit of code</li>
					<ul>
						<li>the <xslta>match</xslta> attribute defines which nodes are processed by a template</li>
						<li>whenever such a node needs to be processed, the template is executed (<q>applied</q>)</li>
						<li>XPaths are interpreted with the matched node as context</li>
					</ul>
					<li>Templates contain a mix of <link href="xslt-literal"/> and XSLT code</li>
					<ul>
						<li><link href="xslt-literal"/> and text nodes are copied to the result tree</li>
						<li>XSLT elements are executed (depending on their semantics)</li>
						<li><xslte>apply-templates</xslte> plays a special role because it selects nodes to be processed</li>
					</ul>
					<li>The template application process is special</li>
					<ul>
						<li>probably the most challenging aspect when learning the language</li>
						<li>XSLT is much easier to use when understanding the underlying principle</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-algorithm">
				<title>Basic Mechanics</title>
				<ol>
					<li>The <em>source node list</em> contains only the root node</li>
					<li>The result tree is created by inserting the result from processing a node from the source node list</li>
					<li>Processing typically puts more nodes on the source node list</li>
					<li>The process is repeated until the source node list is empty</li>
				</ol>
				<listing src="second.xsl" line="5-15"/>
			</slide>
			<slide>
				<title>Template Selection</title>
				<ul>
					<li>Templates are connected through two statements</li>
					<ul>
						<li><xslte>apply-templates</xslte> selects which are put on the source node list</li>
						<li>the XSLT processor selects the best <xslte>template</xslte> and executes it</li>
					</ul>
					<li>What happens if there is no template?</li>
					<ul>
						<li>templates use <link href="xslt-pattern"/> to specify their applicability</li>
						<li>users may not specify a template for a node they select</li>
						<li>instead of an error, <link href="xslt-builtin"/> are used to handle this situation</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-pattern">
				<title>Patterns</title>
				<ul>
					<li>Patterns are a subset of XPath</li>
					<ul>
						<li>they are used to specify to which nodes certain language constructs apply</li>
						<li>patterns specify a set of conditions on a node</li>
					</ul>
					<li>The specification is short, but hard to understand</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xslt#patterns"><q>A node matches a pattern if the node is a member of the result of evaluating the pattern as an expression with respect to some possible context; the possible contexts are those whose context node is the node being matched or one of its ancestors.</q></a></li>
					</ul>
					<li>Practically, patterns are node tests, node contexts, and predicates</li>
					<ul>
						<li><q><code>*</code></q> matches any element</li>
						<li><q><code>tr</code></q> matches <elem>tr</elem> elements</li>
						<li><q><code>thead/tr</code></q> matches <elem>tr</elem> elements within <elem>thead</elem> elements</li>
						<li><q><code>p[@class='warning']</code></q> matches <elem>p</elem> elements with their <xml>class</xml> set to <code>warning</code></li>
						<li>these mechanisms can be combined (and connected by the union operator <q><code>|</code></q>)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Pattern-Based Processing</title>
				<listing src="people-patterns.xsl" line="10-29"/>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Document-Driven Transformations</title>
				<ul>
					<li>XSLT often works best with <em>document-driven</em> programming</li>
					<li>Imperative programmers are used to control the program flow</li>
					<li>Document-driven processing is a powerful design principle</li>
					<li>Variable document types are better handled by document-driven processing</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xslt20-1">
		<title short="XSLT 2.0 1">XML Transformations (XSLT) 2.0 – Part I</title>
		<date>2013-10-28</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xslt20/" title="W3C XSLT 2.0 Specification">Spec</a>&#160;· <a href="xslt2-quickref.pdf">XSLT 2.0 QuickRef</a></toc>
		<toc class="abstract">While <em>XML Transformations (XSLT) 1.0</em> has become a successful programming language widely used for transforming XML documents, its limitations sometimes make it difficult to use XSLT in a good way. An important reason for many of the limitations is the fact that XSLT 1.0 has been designed as a client-side language. Building on XSLT 1.0 and XPath 2.0, <em>XML Transformations (XSLT) 2.0</em> improves the language in a variety of ways.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>XSLT 1.0 Restrictions</title>
			<ul>
				<li>XSLT as a client-side language</li>
				<ul>
					<li>XSLT 1.0 was designed to run in a browser (similar to CSS)</li>
					<li>XSLT today is almost never used as a client-side language</li>
				</ul>
				<li>Processing model geared towards client-side usage</li>
				<ul>
					<li>there always is one input document and one output document</li>
					<li>runtime errors have to be avoided as much as possible</li>
				</ul>
				<li>Data types and XML</li>
				<ul>
					<li>XML is a very weakly <q>typed</q> language (strings, IDs, IDREFs)</li>
					<li>any application data types must be implemented in application code</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>XSLT 2.0 Improvements</title>
			<ul>
				<li>XSLT as a server-side language</li>
				<ul>
					<li>XSLT 2.0 better supports server-side usage</li>
					<li>native XSLT support in browsers might never happen reliably</li>
					<li>shipping XML and transforming it in the browser is not required very often</li>
				</ul>
				<li>Processing model extended to better support server-side usage</li>
				<ul>
					<li>there can be more than one output document</li>
					<li>runtime errors can be a very valuable tool for detecting program errors</li>
				</ul>
				<li><link href="xsd-1">XSD</link> introduces a datatype model for XML</li>
				<ul>
					<li><link href="xsd-simple-types"/> provide a basic vocabulary of datatypes</li>
					<li>many <link href="xpath20">XPath 2.0</link> functions support working with the simple types</li>
					<li><link href="xsd-complex-types"/> allow the definition of structured types</li>
					<li>type checking is supported for simple and complex types</li>
				</ul>
			</ul>
		</slide>
		<part id="xslt20-result-documents">
			<title>Multiple Result Documents</title>
			<slide>
				<title>One XML, Many HTML</title>
				<ul>
					<li>The original model of XSLT 1.0 was a 1:1 mapping of XML and HTML</li>
					<ul>
						<li>a browser retrieves an XML document an generates HTML from it</li>
						<li>this assumed that the granularity of XML is the same as for HTML</li>
					</ul>
					<li>XML documents often represent complex information</li>
					<ul>
						<li>in many cases this is too much information to be displayed on just one HTML page</li>
						<li>typically the complex model of XML is mapped to interlinked HTML</li>
					</ul>
					<li>HTML generated from XML can reflect many different views</li>
					<ul>
						<li>one HTML for each core concept of the XML information model</li>
						<li>indices that make available other HTML through faceted lists</li>
						<li>table of contents using various concepts for listing entries</li>
						<li>alternative representations for core concepts (various dimensions possible)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Generating HTML Pages</title>
				<listing src="references.xsl" line="4-26"/>
			</slide>
			<part id="xslt-identification">
				<title>Creating Identifiers</title>
				<slide>
					<title>Navigable Hypertext</title>
					<ul>
						<li>Create as many hypertext links as possible</li>
						<ul>
							<li>styling should make sure that hyperlink formatting does not degrade legibility</li>
							<li>use different styles for <em>essential links</em> and <em>ancillary links</em></li>
							<li>ancillary links should not use <a href="http://www.webpagesthatsuck.com/mysterymeatnavigation00.html">mystery meat navigation</a>, but something close</li>
						</ul>
						<li>Purely generated pages get generated names</li>
						<ul>
							<li>table of contents and listings based on various criteria</li>
							<li>index pages for better access to page contents</li>
						</ul>
						<li>Pages representing core concepts should get identifier names</li>
						<ul>
							<li>these identifiers should be stable so that bookmarks do not break</li>
							<li>they can <link href="identifier-reuse">reuse XML identifiers</link>, <link href="identifier-derivation">derive identifiers from content</link>, or <link href="identifier-random">generate random identifiers</link></li>
							<li>a well-defined and stable URI naming policy is important</li>
						</ul>
					</ul>
				</slide>
				<slide id="identifier-reuse">
					<title>Reuse Existing Identifiers</title>
					<ul>
						<li>Many core concepts in XML documents have identifiers</li>
						<ul>
							<li>are these identifiers mandatory?</li>
							<li>are these identifiers a good choice for HTML page names?</li>
							<li>sometimes simple string functions can help to create better identifiers</li>
						</ul>
						<li>URI design is a core part of <a href="../web-fall10/rest">REST</a> and essential to good Web architecture</li>
						<li>True REST design will also allow the creation of new resources</li>
						<ul>
							<li>it is possible to <http>PUT</http> new resources into existing collections</li>
							<li>it is possible to <http>POST</http> new resources to existing collections</li>
							<li><http>PUT</http> and <http>POST</http> are different with regard to the resource name</li>
						</ul>
						<li>These identifiers are a core part of the application data model</li>
					</ul>
				</slide>
				<slide id="identifier-derivation">
					<title>Generate Content-Based Identifiers</title>
					<ul>
						<li>Sometimes more <q>speaking</q> identifiers are required</li>
						<ul>
							<li>easier to understand when looking at the identifier and the URI</li>
							<li>often there is a danger of name clashes</li>
						</ul>
						<li>Blogs often use a combination of the post date and the title</li>
						<ul>
							<li>dates should appear as hierarchical path segments such as <code>2007/10/25</code></li>
							<li>titles are appended by matching the post title to URI syntax (replace and truncate)</li>
							<li>name clashes can only occur on the same day using a very similar title</li>
							<li>date navigation can be used to provide access to date-based index pages</li>
						</ul>
						<li>Generated identifiers should be stable (name clashes should not break them)</li>
					</ul>
				</slide>
				<slide id="identifier-random">
					<title>Generate Random Identifiers</title>
					<ul>
						<li>Sometimes it may not be required or possible to reuse data for identifiers</li>
						<ul>
							<li>this may be true if there is no identifier and no <q>main property</q></li>
							<li>generated identifiers can be design to be very compact</li>
						</ul>
						<li>Random identifiers should use some pseudo-random algorithm</li>
						<ul>
							<li>one possible solution is a fingerprint algorithm such as <a href="http://www.miraclesalad.com/webtools/md5.php">MD5</a></li>
							<li>another solution is a really random solution such as <a href="http://tinyurl.com/">TinyURL</a> or <a href="http://is.gd/">is.gd</a></li>
						</ul>
						<li>It is necessary to keep track of the generated identifiers</li>
						<ul>
							<li>collisions are possible (in particular in case of short random values)</li>
							<li>in case of a collision an alternative identifier must be assigned</li>
						</ul>
					</ul>
				</slide>
			<slide>
				<title>Using Existing Identifiers</title>
				<listing src="references.xsl" line="27-47"/>
			</slide>
			</part>
		</part>
		<part id="xslt20-text-processing">
			<title>Text Processing</title>
			<slide>
				<title>Text Processing in XSLT 1.0</title>
				<ul>
					<li>XPath 1.0 provides a small number of <a href="http://www.w3.org/TR/xpath#section-String-Functions">string functions</a></li>
					<ul>
						<li>the selection of functions is very limited and sometimes restrictive</li>
						<li>more advanced functionality is not available (in particular, no <link href="xslt20-regex"/>)</li>
					</ul>
					<li>Text documents cannot be processed at all in XSLT 1.0</li>
					<ul>
						<li>XSLT 1.0 assumes that valuable input data always is XML</li>
						<li>text is a straightforward extension of the XSLT processing model</li>
						<li>binary data access would require a much bigger change of the language</li>
					</ul>
					<li>XSLT 2.0 extends XSLT to support import <em>and</em> export</li>
					<ul>
						<li>XSLT 1.0 already supports text document as an output format</li>
						<li>XSLT 2.0 now supports text documents as an input format</li>
					</ul>
				</ul>
			</slide>
			<part>
				<title>Accessing Text Documents</title>
				<slide>
					<title>Non-XML in an XML World</title>
					<ul>
						<li>Many tools produce text-based output</li>
						<ul>
							<li>text structures are much simpler and often lossy</li>
							<li>at least <em>some</em> data can be used and reused</li>
						</ul>
						<li><xpath>unparsed-text()</xpath> reads a text-based document</li>
						<ul>
							<li>returns a string containing the complete input document</li>
							<li>optionally, an <xpath>encoding</xpath> can be specified (UTF-8 is the default)</li>
						</ul>
						<li>Text documents often also are <q>structured documents</q></li>
						<ul>
							<li>text uses sentences and paragraphs (empty lines) and maybe other <q>markup</q></li>
							<li>text formats often use commas or semicolon or spaces or tabs for structures</li>
							<li>XSLT 2.0's <link href="xslt20-text-transformation">text transformation features</link> support working with these structures</li>
						</ul>
					</ul>
				</slide>
				<slide id="csv">
					<title short="CSV">Comma-Separated Values (CSV)</title>
					<ul>
						<li><a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a> defines a textual format for <q>spreadsheet data</q></li>
						<li>CSV has been used for a long time, but some of the details were solved differently</li>
						<li>Defining a media type makes it easier for implementations to know what to expect</li>
						<ul>
							<li>the CSV registration not only registers the type, but also defines it</li>
						</ul>
						<li>CSV is not overly complex, but some issues have to be solved</li>
						<ul>
							<li>how to separate lines (CRLF)</li>
							<li>how to end the file (CRLF is allowed but optional)</li>
							<li>are headers allowed (yes, but they are not marked as such)</li>
							<li>may different lines use different numbers of fields (no)</li>
							<li>are spaces significant (yes)</li>
							<li>are quotes significant (no, they are delimiters, so quotes as values must be escaped)</li>
							<li>how to treat fields with CRLF, commas, or quotes (enclose the value in quotes)</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xslt20-text-transformation">
				<title>Transforming Text</title>
				<slide id="xslt20-regex">
					<title>Regular Expressions</title>
					<ul>
						<li><link href="xpath">XPath</link> is great for navigating through an XML tree</li>
						<ul>
							<li>all relevant structures of XML are represented and can be navigated</li>
							<li><link href="xpath">XPath 1.0</link> has some <a href="http://www.w3.org/TR/xpath#section-String-Functions">very basic string functions</a> to work with content</li>
							<li><link href="xpath20">XPath 2.0</link> adds <a href="http://www.w3.org/TR/xpath-functions/#string-functions">many more string functions</a></li>
						</ul>
						<li>XPath 2.0 extends the <a href="http://www.w3.org/TR/xmlschema-2/#regexs">regular expression syntax</a> of <link href="xsd-1">XSD</link></li>
						<ul>
							<li>the usual basic expressions known from many languages and tools</li>
							<li><xpath>^</xpath> and <xpath>$</xpath> for matching beginnings and ends (of strings or lines)</li>
							<li>XPath 2.0 supports <em>reluctant quantifiers</em> (indicated by a <xpath>?</xpath> following a quantifier)</li>
							<li>allows access to sub-expressions (important for selective <xpath>replace()</xpath> of substrings)</li>
							<li>allows back-references within expressions (references captured substrings)</li>
						</ul>
						<li>XPath 2.0 supports regular expressions in three functions</li>
						<ul>
							<li>XSLT 2.0 adds an instruction for <a href="xslt20-string-analyzation">parsing strings</a></li>
						</ul>
					</ul>
				</slide>
				<slide id="xslt20-match-replace">
					<title>Matching &amp; Replacing</title>
					<ul>
						<li><xpath>matches()</xpath> tests whether a string matches a given pattern</li>
						<ul>
							<li>an optional <em>flag</em> allows <a href="http://www.w3.org/TR/xpath-functions/#flags">different processing options</a></li>
							<pre>matches("abracadabra", "bra") ≡ true()</pre>
							<pre>matches("abracadabra", "^a.*a$") ≡ true()</pre>
							<pre>matches("abracadabra", "^bra") ≡ false()</pre>
						</ul>
						<li><xpath>replace()</xpath> selectively replaces parts of the input string</li>
						<ul>
							<li>supports the same flag as the <xpath>matches()</xpath> function</li>
							<pre>replace("abracadabra", "bra", "*") ≡ "a*cada*"</pre>
							<pre>replace("abracadabra", "a.*a", "*") ≡ "*"</pre>
							<pre>replace("abracadabra", "a.*?a", "*") ≡ "*c*bra"</pre>
							<pre>replace("abracadabra", "a(.)", "a$1$1") ≡ "abbraccaddabbra"</pre>
							<pre>replace("abracadabra", "^(.*?)b(.*)$", "$1c$2") ≡ "acracadabra"</pre>
						</ul>
					</ul>
				</slide>
				<slide id="xslt20-tokenizing">
					<title>Tokenizing</title>
					<ul>
						<li><xpath>tokenize()</xpath> turns a string into a sequence of strings</li>
						<ul>
							<li>supports the transition from <em>text structures</em> to the XDM concept of sequences</li>
							<li>supports the same flag as the <xpath>matches()</xpath> and <xpath>replace()</xpath> functions</li>
						</ul>
						<li>Tokenization is based on the concept of pattern-based structures</li>
						<ul>
							<li>input strings are using some recognizable way of separating substrings</li>
							<li>a pattern can be used to find substrings and return them as a sequence</li>
							<pre>tokenize("just plain  text", "\s+") ≡ ( "just", "plain", "text" )</pre>
							<pre>tokenize("1,15,,24,50,", ",") ≡ ( "1", "15", "", "24", "50", "" )</pre>
							<pre>tokenize("HTML &lt;BR> tag&lt;br />soup", "\s*&lt;br\s*/?>\s*", "i") ≡ ("HTML", "tag", "soup")</pre>
						</ul>
					</ul>
				</slide>
				<slide id="xslt20-analyze-string">
					<title>Analyzing Strings</title>
					<ul>
						<li>XPath functions work on a string and return strings or sequences</li>
						<li><xslte>analyze-string</xslte> executes XSLT code for parts of the string</li>
						<ul>
							<li>XSLT code can create elements and/or attributes based on string input</li>
							<li>transforming text in XML often is referred to as <em>up-conversion</em></li>
						</ul>
						<li>two children contain code for handling the parsing process</li>
						<ul>
							<li><xslte>matching-substring</xslte> is executed for each matching part</li>
							<li><xslte>non-matching-substring</xslte> is executed for each non-matching part</li>
							<li>both of these elements are optional</li>
							<li>if two adjacent matching substrings are found, <xslte>matching-substring</xslte> is called twice</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Replacing Characters with Elements</title>
					<ul>
						<li>Replace all newline characters in the abstract element by <elem>br/</elem> elements</li>
					</ul>
					<pre><![CDATA[<xsl:analyze-string select="abstract" regex="\n">
  <xsl:matching-substring>
	<br/>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
	<xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>]]></pre>
				</slide>
				<slide>
					<title>Replacing <q>Character Markup</q></title>
					<ul>
						<li>Turn textual conventions into XML markup</li>
						<ul>
							<li>citations are using <q>[…]</q> for the citation identification</li>
						</ul>
					</ul>
					<pre><![CDATA[<xsl:analyze-string select="body" regex="\[(.*?)\]">
  <xsl:matching-substring>
	<cite><xsl:value-of select="regex-group(1)"/></cite>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
	<xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>]]></pre>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>A Better XSLT</title>
				<ul>
					<li>Multiple result documents can generate Web sites from one XML</li>
					<li>Highly interlinked hypertext can be produced by adding HTML links</li>
					<li>Text processing opens a new possibility for XSLT processing</li>
					<li>Regular expression support allows flexible processing of text documents</li>
					<li>XPath 2.0 and XSLT 2.0 support pattern-based text processing</li>
				</ul>
			</slide>
		</part>
	</presentation>
</hotspot>